[toc]

### 设计模式

设计模式一套被反复使用，多数人知晓的代码设计经验的总结，实现可重用代码，使代码更容易被理解，保证代码可靠性。

#### 总体来说，设计模式分为三大类：

###### 创建型模式（五种）：

**工厂方法模式、抽象工厂模式**、**单例模式**、**建造者模式**、原型模式

###### **结构型模式（七种）：**

**适配器模式、装饰器模式**、**代理模式**、外观模式、**桥接模式**、**组合模式**、享元模式

###### 行为型模式（十一种）：

**策略模式**、模板方法模式、**观察者模式**、迭代子模式、**责任链模式**、**命令模式**、备忘录模式、状态模式、访问者模式、**中介者模式**、**解释器模式。**

## 1，单例模式的结构与实现



##### 1.1.1	特点以及定义：

单例（Singleton）模式的定义：指一个类只有一个实例，且该类能自行创建这个实例的一种模式。例如，Windows 中只能打开一个任务管理器，这样可以避免因打开多个任务管理器窗口而造成内存资源的浪费，或出现各个窗口显示内容的不一致等错误。

在计算机系统中，还有 Windows 的回收站、操作系统中的文件系统、多线程中的线程池、显卡的驱动程序对象、打印机的后台处理服务、应用程序的日志对象、数据库的连接池、网站的计数器、Web 应用的配置对象、应用程序中的对话框、系统中的缓存等常常被设计成单例。

###### 单例的三个特点：

1. 单例类只有一个实例对象；
2. 该单例对象必须由单例类自行创建；
3. 单例类对外提供一个访问该单例的全局访问点；



##### 单例模式的结构以及实现：

### 1.2	 单例模式的实现

#### 2.1	Singleton 模式通常有两种实现形式。

#### 第 1 种：懒汉式单例

该模式的特点是类加载时没有生成单例，只有当第一次调用 getlnstance 方法时才去创建这个单例。代码如下：

```java
public class LazySingleton
{
    private static volatile LazySingleton instance=null;    //保证 instance 在所有线程中同步
    private LazySingleton(){}    //private 避免类在外部被实例化
    public static synchronized LazySingleton getInstance()
    {
        //getInstance 方法前加同步
        if(instance==null)
        {
            instance=new LazySingleton();
        }
        return instance;
    }
}
```

######  注意：

如果编写的是多线程程序，则不要删除上例代码中的关键字 volatile 和 synchronized，否则将存在线程非安全的问题。如果不删除这两个关键字就能保证线程安全，但是每次访问时都要同步，会影响性能，且消耗更多的资源，这是懒汉式单例的缺点。 



#### 第 2 种：饿汉式单例

该模式的特点是类一旦加载就创建一个单例，保证在调用 getInstance 方法之前单例已经存在了。

```java
public class HungrySingleton
{
    private static final HungrySingleton instance=new HungrySingleton();
    private HungrySingleton(){}
    public static HungrySingleton getInstance()
    {
        return instance;
    }
}
```

 饿汉式单例在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，所以是线程安全的，可以直接用于多线程而不会出现问题。

##### 拓展：

###### instance什么时候被初始化

 Singleton类被加载的时候就会被初始化，java虚拟机规范虽然没有强制性约束在什么时候开始类加载过程，但是对于类的初始化，虚拟机规范则严格规定了有且只有四种情况必须立即对类进行初始化，遇到new、getStatic、putStatic或invokeStatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。 生成这4条指令最常见的java代码场景是：1）使用new关键字实例化对象2）读取一个类的静态字段（被final修饰、已在编译期把结果放在常量池的静态字段除外）3）设置一个类的静态字段（被final修饰、已在编译期把结果放在常量池的静态字段除外）4）调用一个类的静态方法

######  class的生命周期? 

 class的生命周期一般来说会经历加载、连接、初始化、使用、和卸载五个阶段 

######  class的加载机制 

 这里可以聊下classloader的双亲委派模型。 

#### 第三种：双重检查DCL

```java
public class Singleton {  
    private volatile static Singleton singleton;  
    private Singleton (){}  
    public static Singleton getSingleton() {  
        //判断对象是否被实例化
    if (singleton == null) {  
        //synchronized:
        //lock:
        synchronized (Singleton.class) {  
            //判断该实例是否已经存在
        if (singleton == null) {  
            singleton = new Singleton();  
        }  
        }  
    }  
    return singleton;  
    }  
}  
```

synchronized同步块里面能够保证只创建一个对象。但是通过在synchronized的外面增加一层判断，就可以在对象一经创建以后，不再进入synchronized同步块。这种方案不仅减小了锁的粒度，保证了线程安全，性能方面也得到了大幅提升。

同时这里要注意一定要说volatile，这个很关键，volatile一般用于多线程的可见性，但是这里是用来防止指令重排序的。



##### 拓展：

###### 为什么需要volatile？volatile有什么用？

- 首先要回答可见性，这个是毋庸质疑的，然后可能又会考到java内存模型。
- 防止指令重排序: 防止new Singleton时指令重排序导致其他线程获取到未初始化完的对象。instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。1.给 instance 分配内存2.调用 Singleton 的构造函数来初始化成员变量3.将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了） 但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后报错。
- 顺便也可以说下volatie原理用内存屏障

###### 讲讲synchronized和volatile的区别

这里可以从synchroized能保证原子性，volatile不能保证说起，以及讲下synchroized是重量级锁，甚至可以所以下他和Lock的区别等等。

###### 线程安全一般怎么实现的?

- 互斥同步。如lock,synchroized
- 非阻塞同步。如cas。
- 不同步。如threadLocal,局部变量。




##### 单例模式解决痛点：节省资源，节省时间

1，由于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级的对象而言，是很重要的.

2.因为不需要频繁创建对象，我们的GC压力也减轻了，而在GC中会有STW(stop the world)，从这一方面也节约了GC的时间 单例模式的缺点：简单的单例模式设计开发都比较简单，但是复杂的单例模式需要考虑线程安全等并发问题，引入了部分复杂度。



##### 单例模式的设计：



 下面列举一下需要重点知道的 饿汉，懒汉(线程安全，线程非安全)，双重检查(DCL)(重点),内部类，以及枚举(重点)， 下面比对下各个实现: 

##### 需要考虑的因素：

- 线程安全 
- 延迟加载 
- 代码安全:如防止序列化攻击，防止反射攻击(防止反射进行私有方法调用) 
- 性能因素 

<img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20191128105958329.png" alt="image-20191128105958329"  />






### 1.3	单例模式的应用场景

前面分析了单例模式的结构与特点，以下是它通常适用的场景的特点。

- 在应用场景中，某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。
- 当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。
- 当某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。

### 1.4   单例模式的扩展

单例模式可扩展为有限的多例（Multitcm）模式，这种模式可生成有限个实例并保存在 ArmyList 中，客户需要时可随机获取，其结构图如图 5 所示。

![有限的多例模式的结构图](http://c.biancheng.net/uploads/allimg/181113/3-1Q1131KQ4K8.gif)
图5 有限的多例模式的结构图

## 2，简单工厂模式

#### 2.1	含义

- 简单工厂模式又叫做静态方法模式(工厂类定义了一个静态方法)
- 现实生活中，工厂是负责生产产品的；同样在设计模式中，简单工厂模式我们可以理解为负责生产对象的一个类，简称为“工厂类”

#### 2.2     解决的问题

将“类实例化的操作”与“使用对象的操作”分开，让使用者不用知道具体参数就可以实例化出所需要的“产品”类，从而避免了在客户端代码中显式指定，实现了解耦。

> 即使用者可直接消费产品而不需要知道其生产的细节

------

#### 2.3. 模式原理

##### 2.3.1 模式组成

| 组成（角色）                 |                关系                |                                         作用 |
| ---------------------------- | :--------------------------------: | -------------------------------------------: |
| 抽象产品（Product）          |           具体产品的父类           |                           描述产品的公共接口 |
| 具体产品（Concrete Product） | 抽象产品的子类；工厂类创建的目标类 |                           描述生产的具体产品 |
| 工厂（Creator）              |             被外界调用             | 根据传入不同参数从而创建不同具体产品类的实例 |

##### 2.3.2 UML类图

![img](https:////upload-images.jianshu.io/upload_images/944365-652fab6e6ea33571.png?imageMogr2/auto-orient/strip|imageView2/2/w/510/format/webp)

UML图

##### 2.3.3 使用步骤

- 创建**抽象产品类** & 定义具体产品的公共接口；
- 创建**具体产品类**（继承抽象产品类） & 定义生产的具体产品；
- 创建**工厂类**，通过创建静态方法根据传入不同参数从而创建不同具体产品类的实例；
- 外界通过调用工厂类的静态方法，**传入不同参数**从而创建不同**具体产品类的实例** 

------

#### 2.4. 实例

接下来我用一个实例来对简单工厂模式进行更深一步的介绍。

##### 2.4.1 实例概况

- 背景：小成有一个塑料生产厂，用来做塑料加工生意
- 目的：最近推出了3个产品，小成希望使用**简单工厂模式**实现3款产品的生产

##### 2.4.2 使用步骤

实现代码如下：

**步骤1.** 创建抽象产品类，定义具体产品的公共接口

```csharp
abstract class Product{
    public abstract void Show();
}
```

**步骤2.** 创建具体产品类（继承抽象产品类），定义生产的具体产品

```java
//具体产品类A
class  ProductA extends  Product{

    @Override
    public void Show() {
        System.out.println("生产出了产品A");
    }
}

//具体产品类B
class  ProductB extends  Product{

    @Override
    public void Show() {
        System.out.println("生产出了产品C");
    }
}

//具体产品类C
class  ProductC extends  Product{

    @Override
    public void Show() {
        System.out.println("生产出了产品C");
    }
}
```

**步骤3.** 创建工厂类，通过创建静态方法从而根据传入不同参数创建不同具体产品类的实例

```csharp
class  Factory {
    public static Product Manufacture(String ProductName){
//工厂类里用switch语句控制生产哪种商品；
//使用者只需要调用工厂类的静态方法就可以实现产品类的实例化。
        switch (ProductName){
            case "A":
                return new ProductA();

            case "B":
                return new ProductB();

            case "C":
                return new ProductC();

            default:
                return null;

        }
    }
}
```

**步骤4.** 外界通过调用工厂类的静态方法，传入不同参数从而创建不同具体产品类的实例

```csharp
//工厂产品生产流程
public class SimpleFactoryPattern {
    public static void main(String[] args){
        Factory mFactory = new Factory();

        //客户要产品A
        try {
//调用工厂类的静态方法 & 传入不同参数从而创建产品实例
            mFactory.Manufacture("A").Show();
        }catch (NullPointerException e){
            System.out.println("没有这一类产品");
        }

        //客户要产品B
        try {
            mFactory.Manufacture("B").Show();
        }catch (NullPointerException e){
            System.out.println("没有这一类产品");
        }

        //客户要产品C
        try {
            mFactory.Manufacture("C").Show();
        }catch (NullPointerException e){
            System.out.println("没有这一类产品");
        }

        //客户要产品D
        try {
            mFactory.Manufacture("D").Show();
        }catch (NullPointerException e){
            System.out.println("没有这一类产品");
        }
    }
}
```

###### 结果输出：

```undefined
生产出了产品A
生产出了产品C
生产出了产品C
没有这一类产品
```

------

#### 2.5. 优点

- 将创建实例的工作与使用实例的工作分开，使用者不必关心类对象如何创建，实现了解耦；
- 把初始化实例时的工作放到工厂里进行，使代码更容易维护。 更符合面向对象的原则 & 面向接口编程，而不是面向实现编程。

------

#### 2.6. 缺点

- 工厂类集中了所有实例（产品）的创建逻辑，一旦这个工厂不能正常工作，整个系统都会受到影响；
- 违背“开放 - 关闭原则”，一旦添加新产品就不得不修改工厂类的逻辑，这样就会造成工厂逻辑过于复杂。
- 简单工厂模式由于使用了静态工厂方法，静态方法不能被继承和重写，会造成工厂角色无法形成基于继承的等级结构。

------

#### 2.7. 应用场景

在了解了优缺点后，我们知道了简单工厂模式的应用场景：

- 客户如果只知道传入工厂类的参数，对于如何创建对象的逻辑不关心时；
- 当工厂类负责创建的对象（具体产品）比较少时。

## 3，工厂方法模式

#### 3.1	前言

发现简单工厂模式存在一系列问题：

- 工厂类集中了所有实例（产品）的创建逻辑，一旦这个工厂不能正常工作，整个系统都会受到影响；
- 违背“开放 - 关闭原则”，一旦添加新产品就不得不修改工厂类的逻辑，这样就会造成工厂逻辑过于复杂。
- 简单工厂模式由于使用了静态工厂方法，静态方法不能被继承和重写，会造成工厂角色无法形成基于继承的等级结构。

为了解决上述的问题，我们又使用了一种新的设计模式：工厂方法模式。

#### 3.1.1. 介绍

##### 1.1 定义

工厂方法模式，又称工厂模式、多态工厂模式和虚拟构造器模式，通过定义工厂父类负责定义创建对象的公共接口，而子类则负责生成具体的对象。

##### 1.2 主要作用

将类的实例化（具体产品的创建）延迟到工厂类的子类（具体工厂）中完成，即由子类来决定应该实例化（创建）哪一个类。

##### 1.3 解决的问题

工厂一旦需要生产新产品就需要修改工厂类的方法逻辑，违背了“开放 - 关闭原则

> 1. 即**简单工厂模式**的缺点
> 2. 之所以可以解决简单工厂的问题，是因为工厂方法模式把具体产品的创建推迟到工厂类的子类（具体工厂）中，此时工厂类不再负责所有产品的创建，而只是给出具体工厂必须实现的接口，这样工厂方法模式在添加新产品的时候就不修改工厂类逻辑而是添加新的工厂子类，符合开放封闭原则，克服了简单工厂模式中缺点

------

#### 3.2. 模式原理

##### 2.1 UML类图

![img](https:////upload-images.jianshu.io/upload_images/944365-27764702a32834a3.png?imageMogr2/auto-orient/strip|imageView2/2/w/848/format/webp)

UML类图

##### 2.2 模式组成

| 组成（角色）                 |                关系                |                                                  作用 |
| ---------------------------- | :--------------------------------: | ----------------------------------------------------: |
| 抽象产品（Product）          |           具体产品的父类           |                                描述具体产品的公共接口 |
| 具体产品（Concrete Product） | 抽象产品的子类；工厂类创建的目标类 |                                    描述生产的具体产品 |
| 抽象工厂（Creator）          |           具体工厂的父类           |                                描述具体工厂的公共接口 |
| 具体工厂（Concrete Creator） |     抽象工厂的子类；被外界调用     | 描述具体工厂；实现FactoryMethod工厂方法创建产品的实例 |

##### 2.3 使用步骤

**步骤1：** 创建**抽象工厂类**，定义具体工厂的公共接口；
 **步骤2：** 创建**抽象产品类** ，定义具体产品的公共接口；
 **步骤3：** 创建**具体产品类**（继承抽象产品类） & 定义生产的具体产品；
 **步骤4：**创建**具体工厂类**（继承抽象工厂类），定义创建对应具体产品实例的方法；
 **步骤5：**外界通过调用具体工厂类的方法，从而创建不同**具体产品类的实例**

------

#### 3.3. 实例讲解

接下来我用一个实例来对工厂方法模式进行更深一步的介绍。

##### 3.1 实例概况

- 背景：小成有一间塑料加工厂（仅生产A类产品）；随着客户需求的变化，客户需要生产B类产品；
- 冲突：改变原有塑料加工厂的配置和变化非常困难，假设下一次客户需要再发生变化，再次改变将增大非常大的成本；
- 解决方案：小成决定置办**塑料分厂B**来生产B类产品；

> 即工厂方法模式

##### 3.2 使用步骤

**步骤1：** 创建**抽象工厂类**，定义具体工厂的公共接口

```csharp
abstract class Factory{
    public abstract Product Manufacture();
}
```

**步骤2：** 创建**抽象产品类** ，定义具体产品的公共接口；

```csharp
abstract class Product{
    public abstract void Show();
}
```

**步骤3：** 创建**具体产品类**（继承抽象产品类）， 定义生产的具体产品；

```java
//具体产品A类
class  ProductA extends  Product{
    @Override
    public void Show() {
        System.out.println("生产出了产品A");
    }
}

//具体产品B类
class  ProductB extends  Product{

    @Override
    public void Show() {
        System.out.println("生产出了产品B");
    }
}
```

**步骤4：**创建**具体工厂类**（继承抽象工厂类），定义创建对应具体产品实例的方法；

```java
//工厂A类 - 生产A类产品
class  FactoryA extends Factory{
    @Override
    public Product Manufacture() {
        return new ProductA();
    }
}

//工厂B类 - 生产B类产品
class  FactoryB extends Factory{
    @Override
    public Product Manufacture() {
        return new ProductB();
    }
}
```

**步骤5：**外界通过调用具体工厂类的方法，从而创建不同**具体产品类的实例**

```cpp
//生产工作流程
public class FactoryPattern {
    public static void main(String[] args){
        //客户要产品A
        FactoryA mFactoryA = new FactoryA();
        mFactoryA.Manufacture().Show();

        //客户要产品B
        FactoryB mFactoryB = new FactoryB();
        mFactoryB.Manufacture().Show();
    }
}
```

结果：

```undefined
生产出了产品A
生产出了产品C
```

------

#### 3.4. 优点

- 更符合开-闭原则
   新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可

> 简单工厂模式需要修改工厂类的判断逻辑

- 符合单一职责原则
   每个具体工厂类只负责创建对应的产品

> 简单工厂中的工厂类存在复杂的switch逻辑判断

- 不使用静态工厂方法，可以形成基于继承的等级结构。

> 简单工厂模式的工厂类使用静态工厂方法

总结：工厂模式可以说是简单工厂模式的进一步抽象和拓展，在保留了简单工厂的封装优点的同时，让扩展变得简单，让继承变得可行，增加了多态性的体现。

------

#### 3.5. 缺点

- 添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销；
- 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。
- 虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类；
- 一个具体工厂只能创建一种具体产品

------

#### 3.6. 应用场景

在了解了优缺点后，我总结了工厂方法模式的应用场景：

- 当一个类不知道它所需要的对象的类时
   在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可；
- 当一个类希望通过其子类来指定创建对象时
   在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。
- 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。

## 4，建造者模式

#### 4.1. 简介

##### 1.1 模式说明

隐藏创建对象的建造过程 & 细节，使得用户在不知对象的建造过程 & 细节的情况下，就可直接创建复杂的对象

> 1. 用户只需要给出指定复杂对象的类型和内容；
> 2. 建造者模式负责按顺序创建复杂对象（把内部的建造过程和细节隐藏起来)

##### 1.2 作用（解决的问题）

1. 降低创建复杂对象的复杂度
2. 隔离了创建对象的构建过程 & 表示

从而：

- 方便用户创建复杂的对象（不需要知道实现过程）
- 代码复用性 & 封装性（将对象构建过程和细节进行封装 & 复用）

> 例子：造汽车 & 买汽车。
>
> 1. 工厂（建造者模式）：负责制造汽车（组装过程和细节在工厂内）
> 2. 汽车购买者（用户）：你只需要说出你需要的型号（对象的类型和内容），然后直接购买就可以使用了
>     （不需要知道汽车是怎么组装的（车轮、车门、发动机、方向盘等等））

------

#### 4.2. 模式原理

##### 2.1 UML类图

![img](https:////upload-images.jianshu.io/upload_images/944365-e4842ec60f89315e.png?imageMogr2/auto-orient/strip|imageView2/2/w/860/format/webp)



##### 2.2 模式讲解

1. 指挥者（Director）直接和客户（Client）进行需求沟通；
2. 沟通后指挥者将客户创建产品的需求划分为各个部件的建造请求（Builder）；
3. 将各个部件的建造请求委派到具体的建造者（ConcreteBuilder）；
4. 各个具体建造者负责进行产品部件的构建；
5. 最终构建成具体产品（Product）。

------

#### 4.3.  实例讲解

接下来我用一个实例来对建造者模式进行更深一步的介绍。

##### 3.1 实例概况

- 背景
   小成希望去电脑城买一台组装的台式主机
- 过程

1. 电脑城老板（Diretor）和小成（Client）进行需求沟通（买来打游戏？学习？看片？）
2. 了解需求后，电脑城老板将小成需要的主机划分为各个部件（Builder）的建造请求（CPU、主板blabla）
3. 指挥装机人员（ConcreteBuilder）去构建组件；
4. 将组件组装起来成小成需要的电脑（Product）

##### 3.2 使用步骤

步骤1：定义组装的过程（Builder）：组装电脑的过程

```csharp
public  abstract class Builder {  

//第一步：装CPU
//声明为抽象方法，具体由子类实现 
    public abstract void  BuildCPU()；

//第二步：装主板
//声明为抽象方法，具体由子类实现 
    public abstract void BuildMainboard（）；

//第三步：装硬盘
//声明为抽象方法，具体由子类实现 
    public abstract void BuildHD（）；

//返回产品的方法：获得组装好的电脑
    public abstract Computer GetComputer（）；
}
```

步骤2： 电脑城老板委派任务给装机人员（Director）

```cpp
public class Director{
                        //指挥装机人员组装电脑
                        public void Construct(Builder builder){
                                
                                 builder. BuildCPU();
                                 builder.BuildMainboard（）;
                                 builder. BuildHD（）;
                              }
 }
```

步骤3： 创建具体的建造者（ConcreteBuilder）:装机人员

```java
//装机人员1
  public class ConcreteBuilder extend  Builder{
    //创建产品实例
    Computer computer = new Computer();

    //组装产品
    @Override
    public void  BuildCPU(){  
       computer.Add("组装CPU")
    }  

    @Override
    public void  BuildMainboard（）{  
       computer.Add("组装主板")
    }  

    @Override
    public void  BuildHD（）{  
       computer.Add("组装主板")
    }  

    //返回组装成功的电脑
     @Override
      public  Computer GetComputer（）{  
      return computer
    }  
}
```

步骤4： 定义具体产品类（Product）：电脑

```csharp
public class Computer{
    
    //电脑组件的集合
    private List<String> parts = new ArrayList<String>()；
     
    //用于将组件组装到电脑里
    public void Add(String part){
    parts.add(part);
}
    
    public void Show(){
          for (int i = 0;i<parts.size();i++){    
          System.out.println(“组件”+parts.get(i)+“装好了”);
          }
          System.out.println(“电脑组装完成，请验收”);
          
 
}

}
```

步骤5：客户端调用-小成到电脑城找老板买电脑

```cpp
public class Builder Pattern{
  public static void main(String[] args){

//逛了很久终于发现一家合适的电脑店
//找到该店的老板和装机人员
  Director director = new Director();
  Builder builder = new ConcreteBuilder();

//沟通需求后，老板叫装机人员去装电脑
director.Construct(builder);

//装完后，组装人员搬来组装好的电脑
Computer computer = builder.GetComputer();
//组装人员展示电脑给小成看
computer.Show()；

    }
        
}
   
```

结果输出

```undefined
组件CUP装好了
组件主板装好了
组件硬盘装好了
电脑组装完成，请验收
```

#### 4.4. 特点

在全面解析完后，我来分析下其优缺点：

##### 4.1 优点

- 易于解耦
   将产品本身与产品创建过程进行解耦，可以使用相同的创建过程来得到不同的产品。也就说细节依赖抽象。
- 易于精确控制对象的创建
   将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰
- 易于拓展
   增加新的具体建造者无需修改原有类库的代码，易于拓展，符合“开闭原则“。

> 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。

##### 4.2 缺点

- 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似；如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。
- 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。

------

#### 4.5. 应用场景

- 需要生成的产品对象有复杂的内部结构，这些产品对象具备共性；
- 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。

## 5，责任链模式

#### 定义

​	使多个对象都有机会去处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递请求，只到有一个对象处理它为止

![](C:\Users\Lenovo\Desktop\设计模式\IMG_20191201_231439.jpg)

#### 责任链模式涉及到的角色如下所示：

　　●　　**抽象处理者(Handler)角色：**定义出一个处理请求的接口。如果需要，接口可以定义 出一个方法以设定和返回对下家的引用。这个角色通常由一个Java抽象类或者Java接口实现。上图中Handler类的聚合关系给出了具体子类对下家的引用，抽象方法handleRequest()规范了子类处理请求的操作。

　　●　　**具体处理者(ConcreteHandler)角色：**具体处理者接到请求后，可以选择将请求处理掉，或者将请求传给下家。由于具体处理者持有对下家的引用，因此，如果需要，具体处理者可以访问下家。

#### 纯与不纯的责任链模式

**纯的责任链模式**：

- 一个具体处理者对象只能在两个行为中选择一个：要么承担全部责任，要么将责任推给下家，不允许出现某一个具体处理者对象在承担了一部分或全部责任后 又将责任向下传递的情况
- 一个请求必须被某一个处理者对象所接收，不能出现某个请求未被任何一个处理者对象处理的情况

**不纯的责任链模式**：

- 允许某个请求被一个具体处理者部分处理后再向下传递
- 或者一个具体处理者处理完某请求后其后继处理者可以继续处理该请求
- 而且一个请求可以最终不被任何处理者对象所接收




#### 观察者模式VS责任链模式

责任链模式和观察者模式存在一个共同点，就是传递**责任链模式是一级一级的传递，形成一条链，链节点（处理者）之间是存在传递关系的**。而观察者模式的被观察者向观察者们的传递，**并不是具体观察者之间的传递，观察者之间是不存在关联的**。拿小猿的经历来说，在责任链模式中是请求从技术经理到boss，有层级关系，而对于观察者模式是从被观察者小猿发出，作为观察者的技术经理和boss都会收到小猿的通知，是扩散式的，技术经理和boss并没有层级关系。这是责任链模式和观察者模式的区别，也是责任链模式的核心。

#### 责任链模式的优缺点

##### 优点

1）降低耦合度：客户端不需要知道请求由哪个处理者处理，而处理者也不需要知道处理者之间的传递关系，由系统灵活的组织和分配。

2）良好的扩展性：增加处理者的实现很简单，只需重写处理请求业务逻辑的方法。

##### 缺点

1）请求会从链头发出，直到有处理者响应，在责任链比较长的时候会影响系统性能。

2）请求递归，调试排错比较麻烦。

#### 总结

责任链模式在实际项目中可以用到的地方还是比较多的，比如会员等级系统，会员等级之间构成一条链，用户发起一个请求，系统只要把请求分发到责任链模式的入口，直到传递到与用户会员匹配的等级，这样各个会员等级的业务逻辑就会变成很清晰。这篇折腾了很久，主要是想把责任链的核心阐述清楚，让大家能够容易理解，也让我重新思考了责任链模式的核心。



## 6，观察者模式

#### 定义：

观察者模式又叫做发布——订阅模式，定义了一个对象间的一对多的依赖关系，使得当前对象状态发生变化是，所有依赖他的对象都会收到一个通知并且自动更新自己

#### 特点：

- 被观察者需要持有一个或者是多个观察者对象

- 系统中一个模块的变化，某些模块也会随着变化

  

#### UML：

 ![observer-pattern](https://wiki.jikexueyuan.com/project/java-design-pattern/images/observer-pattern-1.jpg) 

从上面的UML可以看出来，观察者模式设计到的角色有如下四个：

- **抽象被观察者角色**：定义了动态增加、删除以及通知观察者对象的方法，职责就是**管理和通知观察者。持有观察者对象的集合。 从类图中可以看到，类中有一个用来存放观察者对象的Vector容器（之所以使用Vector而不使用List，是因为多线程操作时，Vector在是安全的，而List则是不安全的），这个Vector容器是被观察者类的核心，另外还有三个方法：attach方法是向这个容器中添加观察者对象；detach方法是从容器中移除观察者对象；notify方法是依次调用观察者对象的对应方法。这个角色可以是接口，也可以是抽象类或者具体的类，因为很多情况下会与其他的模式混用，所以使用抽象类的情况比较多。 

-  **具体被观察者角色：**一般继承抽象被观察者，实现自己本身的业务逻辑，当状态发生改变时发起通知。使得这个角色便于扩展，可以在这个角色中定义具体的业务逻辑

- **抽象观察者角色：**提供一个接口，定义了观察者收到通知时更新自己的方法。

-  **具体观察者角色：**实现抽象观察者接口，处理不同具体观察者的不同业务逻辑。



#### 使用观察者模式的场景和优缺点

##### 使用场景

关联行为场景，需要注意的是，关联行为是可拆分的，而不是“组合”关系。
事件多级触发场景。
跨系统的消息交换场景，如消息队列、事件总线的处理机制。

##### 优点

- 观察者和被观察者之间属于轻度的关联关系，并且使抽象耦合的，所以对于两者而言比较容易扩展

- 观察者模式是一种常用的触发机制，形成了一条触发链，对各个观察者的方法进行处理。
- 解除耦合，让耦合的双方都依赖于抽象，从而使得各自的变换都不会影响另一边的变换。

##### 缺点

- 由于是链式触发的，当观察者较多的时候，性能问题比较令人担忧。并且在链式结构中，比较容易出现循环引用的错误，造成系统假死。
- 在应用观察者模式时需要考虑一下开发效率和运行效率的问题，程序中包括一个被观察者、多个观察者，开发、调试等内容会比较复杂，而且在Java中消息的通知一般是顺序执行，那么一个观察者卡顿，会影响整体的执行效率，在这种情况下，一般会采用异步实现。

#### **Android中的观察者模式**

 android源码中也有很多使用了观察者模式，比如OnClickListener、ContentObserver、android.database.Observable等；还有组件通讯库RxJava、RxAndroid、EventBus； 

## 7，桥接模式

#### 定义

桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。

这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。



如果一个系统需要在抽象化和具体化之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系，通过桥接模式可以使它们在抽象层建立一个关联关系。

1. “抽象部分”和“实现部分”可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。
2. 一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立进行扩展。
3. 对于那些不希望使用继承或因为多层继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。

我们通过下面的实例来演示桥接模式（Bridge Pattern）的用法。其中，可以使用相同的抽象类方法但是不同的桥接实现类，来画出不同颜色的圆。

#### 介绍：

**意图：**将抽象部分与实现部分分离，使它们都可以独立的变化。

**主要解决：**在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。

**何时使用：**实现系统可能有多个角度分类，每一种角度都可能变化。

**如何解决：**把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。

**关键代码：**抽象类依赖实现类。

**应用实例：** 1、猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。 2、墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。

**优点：** 1、抽象和实现的分离。 2、优秀的扩展能力。 3、实现细节对客户透明。

**缺点：**桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。

**使用场景：** 1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。

**注意事项：**对于两个独立变化的维度，使用桥接模式再适合不过了。

#### 实现

桥接模式UML 图如下

![img](https://pic1.zhimg.com/80/v2-41d36cd7e00f1ffc54ceaadd1c52d180_hd.jpg)

桥梁模式所涉及的角色有：

- **抽象化(Abstraction)角色**：抽象化给出的定义，并保存一个对实现化对象的引用。
- **修正抽象化(RefinedAbstraction)角色**：扩展抽象化角色，改变和修正父类对抽象化的定义。
- **实现化(Implementor)角色**：这个角色给出实现化角色的接口，但不给出具体的实现。必须指出的是，这个接口不一定和抽象化角色的接口定义相同，实际上，这两个接口可以非常不一样。实现化角色应当只给出底层操作，而抽象化角色应当只给出基于底层操作的更高一层的操作。
- **具体实现化(ConcreteImplementor)角色**：这个角色给出实现化角色接口的具体实现。

抽象化角色就像是一个水杯的手柄，而实现化角色和具体实现化角色就像是水杯的杯身。手柄控制杯身，这就是此模式别名“柄体”的来源。

#### 优缺点

优点：

- 分离抽象接口及其实现部分。桥接模式使用“对象间的关联关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自维度的变化，也就是说抽象和实现不再在同一个继承层次结构中，而是“子类化”它们，使它们各自都具有自己的子类，以便任何组合子类，从而获得多维度组合对象。
- 在很多情况下，桥接模式可以取代多层继承方案，多层继承方案违背了“单一职责原则”，复用性较差，且类的个数非常多，桥接模式是比多层继承方案更好的解决方法，它极大减少了子类的个数。
- 桥接模式提高了系统的可扩展性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统，符合“开闭原则”。

缺点：

- 桥接模式的使用会增加系统的理解与设计难度，由于关联关系建立在抽象层，要求开发者一开始就针对抽象层进行设计与编程。
- 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性，如何正确识别两个独立维度也需要一定的经验积累。

#### **适用场景**

​    在以下情况下可以考虑使用桥接模式：

​    (1)如果一个系统需要在抽象化和具体化之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系，通过桥接模式可以使它们在抽象层建立一个关联关系。

​    (2)“抽象部分”和“实现部分”可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。

​    (3)一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立进行扩展。

​    (4)对于那些不希望使用继承或因为多层继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。

## 8，组合模式

 ![111111_副本](https://images0.cnblogs.com/blog/381060/201309/03205130-d603a9cfaafc4548bcff96a8d56a2f79.png) 

#### 定义：

​	将对象组合成树形结构以表示"部分——整体"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。 组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性，组合模式又可以称为 "整体—部分"(Part-Whole) 模式，它是一种对象结构型模式。 

#### 组合模式类图

 ![Composite pattern class diagram](http://www.jasongj.com/img/designpattern/composite/composite.png)

- 抽象组件，如上图中的Component，可以实接口或者是抽象类，为尾叶子构件和容器构架安安对象生命接口，在该角色中可以包含所有子类共有行为的声明以及实现。在抽象构件中定义了访问以及管理他的构件的方法，如增加子构件，删除子构件，获取子构件等
- 简单组件，如上图中的SimpleComponent。在组合结构中表示叶子节点的对象，叶子节点没有子节点，它实现了在抽象构件中定义的行为。对于那些访问以及管理子构件的方法，可以通过异常等方式进行处理
- 复合组件，如上图中的CompositeComponent

 它在组合结构中表示容器节点对象，容器节点包含子节点，其子节点可以是叶子节点，也可以是容器节点，它提供一个集合用于存储子节点，实现了在抽象构件中定义的行为，包括那些访问及管理子构件的方法，在其业务方法中可以递归调用其子节点的业务方法。

组合模式的**关键是定义了一个抽象构件类，它既可以代表叶子，又可以代表容器**，而客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理。**同时容器对象与抽象构件类之间还建立一个聚合关联关系**，在容器对象中既可以包含叶子，也可以包含容器，以此实现递归组合，形成一个树形结构。

### 透明与安全

在使用组合模式时，根据抽象构件类的定义形式，我们可将组合模式分为透明组合模式和安 全组合模式两种形式。

**透明组合模式**

透明组合模式中，抽象构件角色中声明了所有用于管理成员对象的方法，譬如在示例中 `Component` 声明了 `add`、`remove` 方法，这样做的好处是确保所有的构件类都有相同的接口。透明组合模式也是组合模式的标准形式。

透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的，叶子对象不可能有下一个层次的对象，即不可能包含成员对象，因此为其提供 `add()`、`remove()` 等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错（如果没有提供相应的错误处理代码）

**安全组合模式**

在安全组合模式中，在抽象构件角色中没有声明任何用于管理成员对象的方法，而是在容器构件 `Composite` 类中声明并实现这些方法。



![安全组合模式模式图](https://user-gold-cdn.xitu.io/2018/10/5/1664397434e349bc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



安全组合模式的缺点是不够透明，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。

在实际应用中 `java.awt` 和 `swing` 中的组合模式即为安全组合模式。

### 组合模式总结

组合模式的**主要优点**如下：

- 组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。
- 客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。
- 在组合模式中增加新的容器构件和叶子构件都很方便，无须对现有类库进行任何修改，符合“开闭原则”。
- 组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子对象和容器对象的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。

组合模式的**主要缺点**如下：

- 使得设计更加复杂，客户端需要花更多时间理清类之间的层次关系。
- 在增加新构件时很难对容器中的构件类型进行限制。

**适用场景**：

- 在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，客户端可以一致地对待它们。
- 在一个使用面向对象语言开发的系统中需要处理一个树形结构。
- 在一个系统中能够分离出叶子对象和容器对象，而且它们的类型不固定，需要增加一些新的类型。

#### 

#### 使用场景：

#### Java集合中的组合模式

`HashMap` 提供 `putAll` 的方法，可以将另一个 `Map` 对象放入自己的存储空间中，如果有相同的 key 值则会覆盖之前的 key 值所对应的 value 值

```
public class Test {
    public static void main(String[] args) {
        Map<String, Integer> map1 = new HashMap<String, Integer>();
        map1.put("aa", 1);
        map1.put("bb", 2);
        map1.put("cc", 3);
        System.out.println("map1: " + map1);

        Map<String, Integer> map2 = new LinkedMap();
        map2.put("cc", 4);
        map2.put("dd", 5);
        System.out.println("map2: " + map2);

        map1.putAll(map2);
        System.out.println("map1.putAll(map2): " + map1);
    }
}
复制代码
```

输出结果

```
map1: {aa=1, bb=2, cc=3}
map2: {cc=4, dd=5}
map1.putAll(map2): {aa=1, bb=2, cc=4, dd=5}
复制代码
```

查看 `putAll` 源码

```
    public void putAll(Map<? extends K, ? extends V> m) {
        putMapEntries(m, true);
    }
复制代码
```

`putAll` 接收的参数为父类 `Map` 类型，所以 `HashMap` 是一个容器类，`Map` 的子类为叶子类，当然如果 `Map` 的其他子类也实现了 `putAll` 方法，那么它们都既是容器类，又都是叶子类

同理，`ArrayList` 中的 `addAll(Collection c)` 方法也是一个组合模式的应用，在此不做探讨



#### 优缺点

##### 优点

- 高层模块调用简单。组合秘史中，用户不用关心到底处理的使简单组件耗时符合组件，可以按照统一的接口处理。不必判断组件了我i行，更不用为不同类型组件分开处理
- 很容易的增加新的组件。若要增加一个简单组件或者是符合组件，只需要找到他的富姐键即可，非常容易得到扩展，符合"开放——关闭"原则

##### 缺点

- 无法限制组合组件中的子组件类型。在需要检测组件类型的时候，不能依靠编译器的乐星约束来实现，必须在运行期间动态监测
-  使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。 

## 9，适配器模式

#### 定义

**适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。**



#### 生活实例

 你的iphone x的手机，想要听歌，但是耳机忘记带了，所以和我来借，可是我是国产的OPPO，所以你从包里拿出来一个转换插头，让耳机插到转换插头上，再插到手机上，这个转换插头就是适配器。 

#### 官方解释

 适配器模式将一个类的接口适配成用户所期待的。一个适配器通常允许因为接口不兼容而不能一起工作的类能够在一起工作，做法是将类自己的接口包裹在一个已存在的类中。 

#### 使用契机

- 你想使用现有的类，但是这个类的接口不符合你所需要的。
- 你现在想要创建一个类，用在一些彼此之间没有太大关联的类，包括一些以后将来引进的类一起工作。这些类不一定有一致的接口。
- 想要使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配他们的接口，对象适配器可以是陪他们的父类接口
- 大多数使用第三方库的应用程序使用适配器作为应用程序和第三方库之间的中间层，以将应用程序与库解耦。如果必须使用另一个库，则只需要为新库添加适配器，而不必更改应用程序代码。

#### 适配器模式应用场景

在软件开发中，也就是系统的数据和行为都正确，但接口不相符时，我们应该考虑用适配器，目的是使控制范围之外的一个原有对象与某个接口匹配。适配器模式主要应用于希望复用一些现存的类，但是接口又与复用环境要求不一致的情况。比如在需要对早期代码复用一些功能等应用上很有实际价值。适用场景大致包含三类：

1、已经存在的类的接口不符合我们的需求；

2、创建一个可以复用的类，使得该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作；

3、在不对每一个都进行子类化以匹配它们的接口的情况下，使用一些已经存在的子类。



#### 结论:

##### 类适配器和对象适配器的区别

###### 类适配器

- 通过提交到具体的需要适配的类来使适配器来适应目标类。 因此，当我们想要调整类及其所有子类时，类适配器将不起作用。
- 让适配器覆盖一些适配者的行为， 因为适配器是适配者的子类。
- 只需要引入一个对象，不需要其他的指针来间接的指向适配器。
- 适配器Adapter继承我们的被适配者Adaptee，并实现目标接口。由于Java中是单继承，所以这个适配器仅仅只能服务于所继承的被适配者Adaptee

###### 对象适配器

- 适配器实现我们的目标接口，但是并不继承需要被适配的类。而是通过在适配器的构造函数中将需要被适配的类传递进来从而进行适配
- 让一个适配器与许多适配者一起工作 - 即适配者本身及其所有子类（如果有的话）。 适配器还可以立即向所有适配者添加功能。
- 覆盖适配者Adaptee的方法复杂困难，需要适配器使用一个适配者的子类，不能直接引用适配者。

------

#### 注意事项

1. 充当适配器角色的类就是：实现已有接口的抽象类；
2. 为什么要用抽象类？此类是不要被实例化的。而只充当适配器的角色，也就为其子类提供了一个共同的接口，但其子类又可以将精力只集中在其感兴趣的地方。
3. 适配器模式中被适配的接口 Adaptee 和适配成为的接口 Target 是没有关联的，Adaptee 和 Target 中的方法既可以是相同的，也可以是不同的。
4. 适配器在适配的时候，可以适配多个 Apaptee，也就是说实现某个新的 Target 的功能的时候，需要调用多个模块的功能，适配多个模块的功能才能满足新接口的要求。
5. 适配器有一个潜在的问题，就是被适配的对象不再兼容 Adaptee 的接口，因为适配器只是实现了 Target 的接口。这导致并不是所有 Adaptee 对象可以被使用的地方都能是使用适配器，双向适配器解决了这个问题。

#### 优缺点

##### 优点：

1. 可以让任何两个没有关联的类一起运行。
2. 提高了类的复用。
3. 增加了类的透明度。
4. 灵活性好。
5.  适配器模式也是一种包装模式，它与装饰模式同样具有包装的功能，此外，对象适配器模式还具有委托的意思。总的来说，适配器模式属于补偿模式，专用来在系统后期扩展、修改时使用。 

##### 缺点：

1. 过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。
2. 由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。

#### 10，装饰器模式

#### 概述

 `装饰器模式（Decorator）`,动态地给一个对象添加一些额外的职责，就增加功能来说，装饰器模式比生成子类更为灵活；它允许向一个现有的对象添加新的功能，同时又不改变其结构。 

#### UML类图解析

装饰器模式的UML类图如下：



![decorator](http://upload-images.jianshu.io/upload_images/4651321-8ccf295d2b1a29d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



- **抽象构件角色(Component)**：接口，定义一个抽象接口，真实对象和装饰对象具有相同的接口，以便动态的添加职责。
- **具体构建角色**ConcreteComponent：具体的对象。
- **装设角色**Decorator：装饰类，继承了Component,从外类来扩展Component类的功能，并且持有一个构建引用，进行请求转发。
- **具体装饰角色**ConcreteDecorator：具体装饰类，用于给实际对象添加职责。

#### 装饰模式的优点

- 装饰模式与继承关系的目的都是要拓展对象的功能，但是装饰模式**可以提供比继承更多的灵活性**。装饰模式允许系统动态决定“贴上”一个需要的“装饰”，或者“除掉”一个不需要的“装饰”。继承关系则不同，继承关系是静态的，它在系统运行前就决定了。

- 通过不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出更多不同行为的组合。
-  装饰类和被装饰类都只关心自身的核心业务，实现了解耦。 

#### 装饰模式的缺点

- 由于使用装饰模式，可以比使用继承关系需要较少数目的类。使用较少的类，当然使设计比较易于进行。但是，在另外一方面，使用装饰模式会产生比使用继承关系所产生的更多的对象。而更多的对象会使得查找错误更为困难，特别是这些对象在看上去极为相似的时候。

- 多层装饰比较复杂

  

#### 实际应用

##### 装饰设计模式在JAVA I/O库中的应用

装饰模式在Java语言中最著名的应用莫过于JAVA I/O标准库的设计了。

�由于JAVA I/O库需要很多性能的各种组合，如果这些性能都是用继承的方法实现的，那么每一种组合都需要一种类，这样就会造成大量性能重复的类出现。而如果采用装饰模式，那么类的数目就会大大减少，性能的重复也可以减至最小。因此装饰模式是JAVA I/O�库的基本模式。

JAVA I/O库的对象结构如下图，由于JAVA I/O库的对象众多，因此只画出`InputStream`的部分。

![img](https:////upload-images.jianshu.io/upload_images/5408072-4d91c2b728ef3a96.png?imageMogr2/auto-orient/strip|imageView2/2/w/1068/format/webp)

InputStream结构图

根据上图可以看出：

-  **抽象构建角色(Component)：**由`InputStream`扮演。这是一个抽象类，为各种子类型提供统一的接口。
-  **具体构件角色(ConcreteComponent)：**由`ByteArrayInputStream`、`FileInputStream`、`StringBufferInputStream`等类扮演。它们实现了抽象构件角色所规定的接口。
-  **抽象装饰角色(Decorator)：**由`FilterInputStream`、`ObectInputStream`等类扮演。它们实现了`InputStream`所规定的接口。
-  **具体装饰角色(ConcreteDecorator)：**由几个类扮演，分别是`BufferedInputStream`、`DataInputStream`以及两个不常用到的类`LineNumberInputStream`、`PushbackInputStream`。

#### 11，解释器模式