## 一，Android中的性能优化

#### 简述：

Android作为一个移动设备，无论是内存还是CPU的性能都会受到一定的限制，无法做到像PC设备一样具有超大的内存和高性能的CPU，鉴于此，意味着Android程序不可能无限制的使用内存和CPU资源，过多的使用内存会导致程序内存溢出，即OOM。而过多的使用CPU资源，一般指做大量的耗时操作，会导致手机变得卡顿甚至出现程序无法响应的问题，即ANR。而性能优化一般指的是布局优化，绘制优化，内存泄漏优化，响应速度优化，ListView优化，Bitmap优化，线程优化以及一些性能优化建议等方面



#### 1.1	布局优化

计量减少布局文件的层级，一旦层级减少就会减少Android绘制时的工作量，自然而研究会提高程序的性能

##### 如何实现布局优化

- 删除不居中无用的空间以及层级
- 有选择性的使用性能较低的ViewGroup，比如RelativeLayout
  - 如果既可以采用LinearLayout也可以使用RelativeLayout的话优先使用LinearLayout。
  - 需要嵌套的方式来完成的话推荐使用RelativeLayout，因为ViewGroup的嵌套就相当于增加了布局的层级，同样会降低程序的性能
- 另外一种实现布局优化的方式就是使用<include>，<merge>标签以及ViewSub
  - include：主要用于布局重用
  - merge：一般配合include一起使用，可以降低减少布局的层级
  - ViewSub:提供了按需求加载的功能，当需要时才会将ViewSub中的布局加载到内存，提高了布程序的初始化效率



#### 1.2	绘制优化

指的是View的onDraw方法要避免执行大量的操作，主要体现在两个方面：

- onDraw中不要创建新的局部对象，这是因为onDraw方法会被频繁调用，这样就会在一瞬间产生大量的临时对象，这不仅占用了过多的内存还会导致系统更加频繁的GC，降低了程序的执行效率

- onDraw方法中不要做好事的任务，也不能执行成千上万此的循环操作，尽管每次循环都是轻量级的，但是大量的操作仍旧会抢占CPU的时间片，会造成View的绘制过程不流畅。而谷歌给出的官方性能优化典范的标准中，View的绘制帧率保证60fps最佳，每帧绘制时间不得超过16ms



#### 1.3	内存泄漏优化

- 静态变量导致的内存泄漏

- 单例模式导致的内存泄漏

- 属性动画导致的内存泄漏

  Android3.0开始，谷歌提供了属性动画，而属性动画中有一类无限循环的动画，如果在Activity中播放此类动画而没有在onDestroy中停止得话，则动画会一直播放，尽管在界面上看不到动画效果，并且此时的Activity会一直被该动画所持有，而View有持有了Activity，最终会导致Activity无法被释放。

  解决方法：

  在Activity的onDestroy中调用animator.cancle()来停止动画

  



#### 1.4   ListView和Bitmap的优化

ListView：

- 采用ViewHolder并且避免在getView中执行耗时操作

- 根据列表的滑动状态来控制任务的执行频率，比如当前列表快速滑动时显然是不太适合开启大量的异步任务的

- 尝试开启硬件加速来时的ListView更加流畅

  注：ListView的优化策略完全适用于GridView

#### 1.5   线程优化

采用线程池，避免程序中存在大量的Thread。线程池可以重用内部的线程，从而避免线程创建和销毁带来的开销，同时线程池还能有效的控制线程池的最大并发数，避免大量的线程因抢占资源而导致阻塞现象的产生。因此创建线程的时候建议使用线程池，而不是每次都要创建一个Thread对象

#### 1.6	优化建议

- 避免创建过多的对象
- 不要过多的使用枚举，枚举占用的内存空间要比整型大
- 常量请使用static  final修饰
- 适当使用软引用以及弱引用
- 采用内存缓存和磁盘缓存
- 使用一些Android特有的数据结构，比如SparseArray以及Pair等，他们都具有更好的性能
- 尽量使用静态内部类，这样可以避免潜在的由于内部类导致的内存泄漏