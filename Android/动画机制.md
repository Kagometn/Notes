### 动画机制

#### 原理：

- Animation框架定义了透明度，旋转，缩放和位移几种常见的动画，而且控制的是整个View

- 实现原理是每次绘制视图时View所在的ViewGroup中的drawChild函数获取该View的Animation的Transformation值

- 然后调用canvas.concat(transformToApply.getMatrix())，通过矩阵运算完成动画帧，如果动画没有完成，继续调用invalidate()函数，启动下次绘制来驱动动画

- 动画过程中的帧之间间隙时间是绘制函数所消耗的时间，可能会导致动画消耗比较多的CPU资源，最重要的是，动画改变的只是显示，并不能相应事件

#### 概述：

安卓中的动画分为两大类，三种动画：**视图动画以及属性动画**两大类，补间动画&逐帧动画

 ![《Android必读之Android 动画种类详解》](http://47.100.55.132/wp-content/uploads/2019/05/16323c6fd0ca5a9a.png)

 

Tween动画，这种实现方式可以使视图组件移动、放大、缩小以及产生透明度的变化;
在做项目的过程中，客户要求从左至右播放一次动画的过程，就是采用的是补间动画，设置了动画播放的时间，开始位置与起始位置，播放完毕回到原来的起始位置。

Frame动画，传统的动画方法，通过顺序的播放排列好的图片来实现，类似电影。

#### 视图动画



##### 逐帧动画/图像动画(Drawable Animation)

 ![《Android必读之Android 动画种类详解》](http://47.100.55.132/wp-content/uploads/2019/05/16323c6fd0e98f5a.png) 

- 通过指定每一帧的图片和播放时间，有序的进行播放而形成动画的效果

- ```java
  //在drawable目录下定义xml文件，子节点为animation-list，在这里定义要显示的图片和每张图片的显示时长    
          <animation-list xmlns:android="http://schemas.android.com/apk/res/android" android:oneshot="false">
              <item android:drawable="@drawable/g1" android:duration="200" />
              <item android:drawable="@drawable/g2" android:duration="200" />
              <item android:drawable="@drawable/g3" android:duration="200" />
          </animation-list>
  //* 在屏幕上播放帧动画
          ImageView iv = (ImageView) findViewById(R.id.iv);
          //把动画文件设置为imageView的背景
          iv.setBackgroundResource(R.drawable.animations);
          AnimationDrawable ad = (AnimationDrawable) iv.getBackground();
          //播放动画        
          ad.start();
  
  ```

##### 补间动画/视图动画(View  Animation)

 ![《Android必读之Android 动画种类详解》](http://47.100.55.132/wp-content/uploads/2019/05/16323c6fd0d50fc3.jpg) 

- 分类 根据不同的动画效果，补间动画分为4种动画，具体如下图

  通过指 ![《Android必读之Android 动画种类详解》](http://47.100.55.132/wp-content/uploads/2019/05/16323c6fd104d082.png) 

- 定View的初始状态，变化时间，方式，通过一系列的算法去进行图像变换，从而达到动画的效果，主要有Translate，Scale，Rotate，Alpha四种效果对应一下四种

  注：只是在视图层实现动画效果，并没有真正改变View 的属性

- 位移动画

  ```java
  //位移：
  * 参数10指的是X的起点坐标，但不是指屏幕x坐标为10的位置，而是imageview的 真实X + 10
  * 参数150指的是X的终点坐标，它的值是imageview的 真实X + 150    
          //创建为位移动画对象，设置动画的初始位置和结束位置
          TranslateAnimation ta = new TranslateAnimation(10, 150, 20, 140);
  * x坐标的起点位置，如果相对于自己，传0.5f，那么起点坐标就是 真实X + 0.5 * iv宽度
  * x坐标的终点位置，如果传入2，那么终点坐标就是 真实X + 2 * iv的宽度
  * y坐标的起点位置，如果传入0.5f，那么起点坐标就是 真实Y + 0.5 * iv高度
  * y坐标的终点位置，如果传入2，那么终点坐标就是 真实Y + 2 * iv高度
          TranslateAnimation ta = new TranslateAnimation(Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 2, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 2);
  * 动画播放相关的设置
          //设置动画持续时间
          ta.setDuration(2000);
          //动画重复播放的次数
          ta.setRepeatCount(1);
          //动画重复播放的模式
          ta.setRepeatMode(Animation.REVERSE);
          //动画播放完毕后，组件停留在动画结束的位置上
          ta.setFillAfter(true);
          //播放动画
          iv.startAnimation(ta);
  ```

  

- 缩放动画

  ```java
  参数0.1f表示动画的起始宽度是真实宽度的0.1倍
  * 参数4表示动画的结束宽度是真实宽度的4倍
  * 缩放的中心点在iv左上角
          ScaleAnimation sa = new ScaleAnimation(0.1f, 4, 0.1f, 4);
  * 参数0.1f和4意义与上面相同
  * 改变缩放的中心点：传入的两个0.5f，类型都是相对于自己，这两个参数改变了缩放的中心点
  * 中心点x坐标 = 真实X + 0.5 * iv宽度
  * 中心点Y坐标 = 真实Y + 0.5 * iv高度
      ScaleAnimation sa = new ScaleAnimation(0.1f, 4, 0.1f, 4, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);
  ```

  

- 旋转动画

  ```java
  * 20表示动画开始时的iv的角度
  * 360表示动画结束时iv的角度
  * 默认旋转的圆心在iv左上角
          RotateAnimation ra = new RotateAnimation(20, 360);
  * 20,360的意义和上面一样
  * 指定圆心坐标，相对于自己，值传入0.5，那么圆心的x坐标：真实X + iv宽度 * 0.5
  * 圆心的Y坐标：真实Y + iv高度 * 0.5
          RotateAnimation ra = new RotateAnimation(20, 360, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);
  ```

  

- 透明动画

  ```java
   0为完全透明，1为完全不透明
          AlphaAnimation aa = new AlphaAnimation(0, 0.5f);
  ```

  

- 集合

  XML中：

  | alpha     | 渐变透明度动画效果       |
  | --------- | ------------------------ |
  | scale     | 渐变尺寸伸缩动画效果     |
  | translate | 画面转换位置移动动画效果 |
  | rotate    | 画面转移旋转动画效果     |
  |           |                          |

  

##### 属性动画(Property Animation)

是3.0之后提供的一种全新动画模式

###### 提出原因

 ![《Android必读之Android 动画种类详解》](http://47.100.55.132/wp-content/uploads/2019/05/16323c6fd11a9ba8.jpg) 

通过不断地改变View的属性，不断地重回而形成的动画效果。相较于视图动画，View的属性值真正改变了

- 拥有补间动画的所有功能

  

###### 具体介绍

###### 简介

 ![《Android必读之Android 动画种类详解》](http://47.100.55.132/wp-content/uploads/2019/05/16323c6fea11da8f.png) 

具体使用：

  属性动画的使用类主要是：`ValueAnimator` 类 & `ObjectAnimator` 类，具体介绍如下 

 ![《Android必读之Android 动画种类详解》](http://47.100.55.132/wp-content/uploads/2019/05/16323c6fef0031b0.png) 



##### 动画 总结 & 对比

总结

<img src="http://47.100.55.132/wp-content/uploads/2019/05/16323c6ff12dbc73.png" alt="《Android必读之Android 动画种类详解》" style="zoom:200%;" />

###### 两类动画的区别

两类动画的根本区别在于：**是否改变动画本身的属性**：

- 视图动画：无改变动画的属性 因为视图动画在动画过程中仅对图像进行变换(平移、缩放、旋转和透明)，从而达到了动画效果
- 属性动画：改变了动画属性 因属性动画在动画过程中对动态改变了对象属性，从而达到了动画效果



属性动画与补间动画的区别：

- 补间动画
  - 是父容器不断地绘制View，看起来像移动效果，其实View没有移动还在原地
- 属性动画
  - 是通过不断改变自己View的属性值真正的改变View

代码如下：

```java
//补间动画
public void clickViewAnimation(View view) {
    //位移动画,x方向不变,y有0->250
    TranslateAnimation animation = new TranslateAnimation(0, 0, 0, 250);
    //时长
    animation.setDuration(2000);
    //停在结果位置
    animation.setFillAfter(true);
    //控件开始动画,传入动画
    iv.startAnimation(animation);
}
//属性动画
public void clickViewProperty(View view) {
    //动画对象:控件以及动画的类型都写在里面,然后是一组"不尽"的数组:比如Y方向的0->250又上又下
    ObjectAnimator animator = ObjectAnimator.ofFloat(iv, "translationY", 0,
            250, 100, 200, 250);
    //时长
    animator.setDuration(5000);
    //对象开始
    animator.start();
}
//测试他两的区别
public void clickIv(View view) {
    Toast.makeText(this, "点击了图片", Toast.LENGTH_SHORT).show();
}

```





动画的特殊场景：

- ListView的
- 三个重要的出场效果：

### 2.知道SVG & 矢量动画吗？

#### 概述：



相较我们通常使用的png，jpg等格式的位图（Bitmap），SVG拥有体积相对较小，通过描述的形式记录形状，因此可以适应各种大小分辨率而不会失真。

而在Android中，我们不能直接使用原始的 .svg 格式图片，而是需要将其转化为 VectorDrawable，可以理解为一个XML格式的svg文件，即矢量图形在android中的原始资源。 SVG拥有体积相对较小，通过描述的形式记录形状，因此可以适应各种大小分辨率而不会失真。 

 .svg格式相对于.jpg、.png甚至.webp具有较多优势，我认为核心有两点：
 1.省时间。图像与分辨率无关，收放自如，适配安卓机坑爹的分辨率真是一劳永逸；
 2.省空间。体积小，一般复杂图像也能在数KB搞定，图标更不在话下。 

#### 矢量动图：

  VectorDrawable是Google从Android 5.0开始引入的一个新的Drawable子类，能够加载矢量图。到现在通过support-library已经至少能适配到Android 4.0了（通过AppBrain统计的Android版本分布来看，Android 4.1以下（api<15）几乎可以不考虑了）。Android中的VectorDrawable只支持SVG的部分属性，相当于阉割版。 



如果只是单纯的运用VectorDrawable，似乎作用就只有缩小apk资源文件体积了，还要考虑svg运行时才计算所造成的额外cpu消耗（将形状描述转化为图形）。但是有了AnimatedVectorDrawable之后，就完全不一样了。

AnimatedVectorDrawable通过ObjectAnimator属性动画控制VectorDrawable，利用矢量图形的特性，从而达成各种炫酷的动画效果。

 ![img](https://upload-images.jianshu.io/upload_images/3910623-acc5a19e1f59828e.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

 其主要动画效果分为以下三种：

- 两个图形之间的无缝切换

   ![img](https://upload-images.jianshu.io/upload_images/3910623-bfc714fc78615576.gif?imageMogr2/auto-orient/strip|imageView2/2/w/190/format/webp) 

- 按路径绘制图像

   ![img](https://upload-images.jianshu.io/upload_images/3910623-0fdfb055a9814c6b.gif?imageMogr2/auto-orient/strip|imageView2/2/w/184/format/webp) 

- 分组控制图像不同部分

   ![img](https://upload-images.jianshu.io/upload_images/3910623-4a709881c00798a3.gif?imageMogr2/auto-orient/strip|imageView2/2/w/184/format/webp) 

  

  

  

  ###### SVG和Vector的区别：

  SVG，即Scalable Vector Graphics 矢量图，这种图像格式在前端中已经使用的非常广泛了。
  Vector，在Android中指的是Vector Drawable，也就是Android中的矢量图，
  SVG：通常在前端中使用，是一套语法规范，GPU根据该规范绘制图片。SVG中会有很多标签用于绘制图片，如：rest、circle、polyline、line、path等。

  Vector:通常在Android中使用，只实现了SVG语法中的path标签，可以视为简单化的矢量图。

  SVG在加载过程中，效率比较低，而android的Vector只采用了SVG的path标签，如此设计就是为了提高SVG加载的效率
   同样一张图片，PNG格式的5.6K，而SVG的2.6K，经过压缩后的Vector格式的图片只有1.5K，这是实用Vector图片的第二个好处，除了支持随意放大缩小之外，还极大减小占用体积。
   利用Android Studio的Vector Asset，可以非常方便的创建Vector图像，甚至可以直接通过本地的SVG图像来生成Vector图像。
  Vector中利用不同字母来代表不同含义，实现图片的绘制，下面我们简单看一下这三个指令：

  M = moveto(M X,Y) ：将画笔移动到指定的坐标位置

  L = lineto(L X,Y) ：画直线到指定的坐标位置

  H = horizontal lineto(H X)：画水平线到指定的X坐标位置

  V = vertical lineto(V Y)：画垂直线到指定的Y坐标位置

  C = curveto(C X1,Y1,X2,Y2,ENDX,ENDY)：三次贝赛曲线

  S = smooth curveto(S X2,Y2,ENDX,ENDY)
  Q = quadratic Belzier curve(Q X,Y,ENDX,ENDY)：二次贝赛曲线

  T = smooth quadratic Belzier curveto(T ENDX,ENDY)：映射

  A = elliptical Arc(A RX,RY,XROTATION,FLAG1,FLAG2,X,Y)：弧线

  Z = closepath()：关闭路径

  <vector xmlns:android="http://schemas.android.com/apk/res/android"
      android:width="24dp"
      android:height="24dp"
      android:viewportHeight="500.0"
      android:viewportWidth="500.0">
      <path
        android:fillColor="#FF000000"
        android:pathData="M100,100 L400,100 L100,400 Z" />
    </vector>

   简单图形手写pathData还行，可是比较复杂的图形怎么办呢，当然有绘制工具了，这里介绍一个SVG Editor：http://editor.method.ac/，我们可以在这行面绘制复杂的数量图形，然后导出SVG格式的图像，而android中无法直接使用SVG格式的图，所以我们可以通过http://inloop.github.io/svg2android/来进行SVG到Vector的转化，是不是很方便呢。。
   VectorDrawable是在android L中提出来的，也就是说VectorDrawable只兼容minSDK>=21的版本，这个限制是非常大的，我们知道，目前市面上的Android版本比较混乱，各种版本的android手机都存在，这就导致VectorDrawable系统兼容性非常差。
    VectorDrawable可以为我们的应用带来很多好处，Google也非常重视VectorDrawable的发展，后来在Gradle Plugin1.5中，Google为VectorDrawable做了兼容，主要实现是这样的：
     
  当手机设备系统版本>=21 —> 实用Vector； 
  当手机设备系统版本<21  —>将Vector转化为PNG格式显示，而这一步转化是在编译时自动完成的；
   而VectorDrawable真正的春天要等到AppCompat23.2的到来，Google在AppCompat23.2中增加了VectorDrawable全版本兼容，它使得静态的VectorDrawable可以支持到android2.1+，而动态的VectorDrawable可以支持到android3.0+的设备，这两个版本几乎已经包含了市面上90%＋的android手机设备。
  <ImageView
      android:layout_width="100dp"
      android:layout_height="100dp"
      app:srcCompat="@drawable/ic_face_black_24dp”/>

  1，SVG何以可以任意缩放而不会失真，drawable-(m|h|xh|xxh|xxxh)dpi和mipmap-(m|h|xh|xxh|xxxh)dpi这俩货就可以省省了；2，SVG文件一般都比较小，省去很去资源达到apk缩包的目的；3，SVG占用内存非常小，性能高。但是SVG明显的缺点是没有位图表达的色彩丰富。

  增加对Vector兼容性的支持，使用Gradle Plugin 2.0以上：
  android {
    defaultConfig {
      vectorDrawables.useSupportLibrary = true
    }
  }
  增加对Vector兼容性的支持，使用Gradle Plugin 2.0以下，Gradle Plugin 1.5以上：
  android {
   defaultConfig {
    // Stops the Gradle plugin’s automatic rasterization of vectors
    generatedDensities = []
   }
   // Flag to tell aapt to keep the attribute ids around
   aaptOptions {
    additionalParameters "--no-version-vectors"
   }
  }

  \> vector矢量图

  Android使用矢量图（SVG, VectorDrawable）实践篇- https://www.jianshu.com/p/0555b8c1d26a
  矢量图- https://www.iconfont.cn/search/index?q=%E4%B8%89%E8%A7%92%E5%BD%A2
  Android vector pathData命令介绍- https://blog.csdn.net/n4167/article/details/79184286

  Android Vector曲折的兼容之路- https://blog.csdn.net/u012702708/article/details/53081055
  Vector Path指令解析如下所示,支持的指令：
  M = moveto(M X,Y) ：将画笔移动到指定的坐标位置
  L = lineto(L X,Y) ：画直线到指定的坐标位置
  H = horizontal lineto(H X)：画水平线到指定的X坐标位置
  V = vertical lineto(V Y)：画垂直线到指定的Y坐标位置
  C = curveto(C X1,Y1,X2,Y2,ENDX,ENDY)：三次贝赛曲线
  S = smooth curveto(S X2,Y2,ENDX,ENDY)
  Q = quadratic Belzier curve(Q X,Y,ENDX,ENDY)：二次贝赛曲线
  T = smooth quadratic Belzier curveto(T ENDX,ENDY)：映射
  A = elliptical Arc(A RX,RY,XROTATION,FLAG1,FLAG2,X,Y)：弧线
  Z = closepath()：关闭路径

  <?xml version="1.0" encoding="utf-8"?>
  <vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="100dp"
    android:height="100dp"
    android:viewportHeight="100.0"
    android:viewportWidth="100.0">
    <path
      android:pathData=""
      android:strokeColor="#0077e6"
      android:strokeWidth="0.3" />
  </vector>

​    

### 3.给我说说转场动画

#### 概述：

是Android L引入的动画效果，可以说是API19引入的场景(Scene)动画的扩展，使得开发者更加方便的实现布局(界面)变化时候的过渡动画

#### 转场动画(Transition)

在在android.transition包下提供关于transitionAnimation的过渡框架, Transiton框架是在api19引入, 但是转场动画却是在api21引入.

Tip: 某些动画效果可能需要api23之上

类关系:

- Transition 
  - ChangeBounds  改变目标视图的布局边界
  - ChangeClipBounds 裁剪目标视图边界
  - ChangeTransform 改变目标视图的缩放比例和旋转角度
  - ChangeImageTransform 改变目标图片的大小和缩放比例
  - ChangeScroll
  - TransitionSet 
    - AutoTransition 默认过渡动画
  - Visibility 其子类都属于界面切换动画 
    - Explode 爆炸
    - Fade 淡出
    - Slide 上下滑动

Transition是一个不需要考虑关键帧(keyFrame)只需要告诉系统你想要的动画效果就能实现其过渡

带有change前缀的Transition的子类只是针对特有属性才有效果

而Visibility的子类是针对共享元素的坐标创建动画效果

简单的效果实现演示:

界面A

```java
public class MainActivity extends AppCompatActivity {

    @BindView(R.id.button) Button mButton;

    @Override protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        ButterKnife.bind(this);
    }

    @OnClick(R.id.button) public void onClick() {
        startActivity(new Intent(this, SecondActivity.class), ActivityOptionsCompat.makeSceneTransitionAnimation(this).toBundle());
    }
}
```

界面B

```java
public class SecondActivity extends AppCompatActivity {

    @Override protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        getWindow().requestFeature(Window.FEATURE_CONTENT_TRANSITIONS); // 必须
        setContentView(R.layout.activity_second);

        getWindow().setExitTransition(new Slide());
        getWindow().setEnterTransition(new Slide());
    }
}

```

Tip: 官方文档说明转场动画要求当前Activity必须在setContentView之前写入如下代码, 不过api21以上并不需要以下设置.

```java
getWindow().requestFeature(Window.FEATURE_CONTENT_TRANSITIONS);
```

如果要退出界面仍然有transition动画不能执行finish, 需要执行`finishAfterTransition()`



#### 动画目标

默认转场动画会对所有的子View进行遍历加载动画，但是如果添加目标则不会遍历所有子View，或者也可以拍出特定的View

对目标有以下三个操作：

- 添加

  默认会进行遍历所有的视图加载动画，但是如果使用了添加就不会遍历所有，只会让指定的视图进行动画

- 排除

  如果使用排除方法，依旧会进行遍历视图对象，不过会排除指定的视图

- 删除

  删除目标是在动画已经遍历视图完成以后还想对目标集合进行变更，就可以删除指定的视图



添加/排除和删除目标支持以下参数类型

1. 视图对象(View)
2. 过渡名(TransitionNames)
3. 字节码(Class)
4. ID

```java
Transition addTarget (View target)

Transition addTarget (String targetName)

Transition addTarget (Class targetType)

Transition addTarget (int targetId)
```

删除是`removeTarget()`, 排除是`excludeTarget()`

转场动画都支持设置监听器

```
Transition addListener (Transition.TransitionListener listener)
复制代码
```

TransitionListener和AnimatorListener一样的重写方法.

#### 窗口(Window)

从示例可以看出转场动画在代码中是通过获取Window对象进行设置的. 看下Window有哪些关于转场动画的方法.

转场动画有四种场景:

```java
// 当前界面进入动画
void setEnterTransition (Transition transition)
// 当前界面退出动画
void setExitTransition (Transition transition)
  
// 以下介绍的是返回时的动画, 如果不设置就会默认和进入和退出动画相同
  
// 下个界面返回当前界面时, 当前界面进入动画
void setReenterTransition (Transition transition)
  
// 返回上个界面时当前界面退出动画
void setReturnTransition (Transition transition)
```

默认情况下界面A的退出动画还没有结束时, 界面B的进入动画就会开始执行. 以下两个方法默认为true. 想要进入动画等待退出动画结束后再播放就需要以下两个方法设置为false.

建议处于默认开启的状态, 否则可能出现背景空白期. 如果想清晰的看出几个不同状态的动画顺序可以开启

```java
void setAllowEnterTransitionOverlap (boolean allow)
void setAllowReturnTransitionOverlap (boolean allow)
```

直接设置一个

```java
void setTransitionManager (TransitionManager tm)
```

在分享元素过渡的时候是否允许重叠

```java
void setSharedElementsUseOverlay (boolean sharedElementsUseOverlay)
```

Tip: 转场动画还支持主题文件里面直接设置

#### 界面选项(ActivityOptions)

如果想兼容api16之前的系统版本可以使用`ActivityOptionsCompat`

该类用跳转界面的使用作为可选参数传递;

如果想让转场动画生效就必须使用下面两种方法开启界面

```java
// 单一共享元素, 如果没有共享元素传入NULL
ActivityOptions makeSceneTransitionAnimation (Activity activity, 
                View sharedElement, 
                String sharedElementName)

// 支持多个共享元素
ActivityOptions makeSceneTransitionAnimation (Activity activity, 
                Pair...<View, String> sharedElements)
```

自定义进入和退出动画, 和overridePendingTransition方法一样

```java
ActivityOptions makeCustomAnimation (Context context, 
                int enterResId, 
                int exitResId)
```

下面介绍三种系统提供的默认动画效果, 我实际使用感觉效果不是很明显, 感觉用处不大.

裁剪动画, 这是api23(Android m) 新增api.

```java
ActivityOptions makeClipRevealAnimation (View source, 
                int startX, 
                int startY, 
                int width, 
                int height)
```

缩放动画

```java
ActivityOptions makeScaleUpAnimation (View source, 
                int startX, 
                int startY, 
                int width, 
                int height)
```

缩略图

```java
ActivityOptions makeThumbnailScaleUpAnimation (View source, 
                Bitmap thumbnail, 
                int startX, 
                int startY)
```

#### 场景(Scene)

场景可以理解为在一个界面(Activity)当中切换或者改变布局内容, 场景是在api19引入

创建方式有两种, 一种是通过以下的静态方法直接创建

```java
Scene getSceneForLayout (ViewGroup sceneRoot, 
                int layoutId, 
                Context context)
```

或者通过构造方法

```java
Scene (ViewGroup sceneRoot,  // 当前场景
                View layout) // 需要进入的新场景
```

sceneRoot可以称为**根视图**. 在官方示例中是当前界面布局的视图对象, 可以理解为其场景(Scene)依附的Activity容器

如果你需要动态的设置场景的视图内容, 可以只指定**根视图**

```java
Scene (ViewGroup sceneRoot)
```

进入场景和退出场景, 不带任何动画. 一般情况下场景的进入由TransitionManager负责

```java
void enter ()

void exit ()
```

exit并不会对场景有任何变化

在场景进入和退出时可以设置两个回调方法

```java
void setEnterAction (Runnable action)

void setExitAction (Runnable action)
```

Tip: 如果两个场景存在相同的ID会自动进行共享元素动画(前提是用的不是默认的AutoTransiton, 因为该类没有使用Change)

#### 过渡管理器(TransitionManager)

Scene默认是没有针对场景的变化, TransitionManager提供两种方式

1. 这种默认的过渡动画是 AutoTransition

   ```java
   static void go (Scene scene)
   ```

   

2. 自定义过渡动画

   ```java
   static void go (Scene scene, 
                   Transition transition)
   ```

开始延迟过渡, 即保存当前视图的属性状态, 然后在之后其发生改变的时候自动进行过渡动画

```java
void beginDelayedTransition (ViewGroup sceneRoot)

void beginDelayedTransition (ViewGroup sceneRoot, 
                Transition transition)
```

后面还可以结束自动保存属性状态

```java
void endTransitions (ViewGroup sceneRoot)
```

场景切换

```java
// 创建一个自定义Transition动画的TransitionManager
mTransitionManagerForScene3 = TransitionInflater.from(getActivity())
.inflateTransitionManager(R.transition.scene3_transition_manager, mSceneRoot);

// 然后切换任意布局
mTransitionManagerForScene3.transitionTo(mScene3);
```

该方法等同于提到的`go()`

```java
void transitionTo (Scene scene)
```

#### XML定义

不同于普通的动画, 转场动画拥有专属的资源目录transition

在res/transition目录下创建XML文件

![img](https://user-gold-cdn.xitu.io/2018/5/30/163b0b8ca7992c73?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

标签一览

![img](https://user-gold-cdn.xitu.io/2018/5/30/163b0b8ca79492ed?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

引用XML

```
  Transition explode = TransitionInflater.from(this).inflateTransition(R.transition.explode);
复制代码
```

或者可以直接在主题中设置

```
<item name="android:windowExitTransition">@transition/explode</item>
<item name="android:windowEnterAnimation">@transition/explode</item>
<item name="android:windowReenterTransition">@transition/explode</item>
复制代码
```

TransitionInflat除上面提到的方法外还可以填充trantionManager对象

```
TransitionManager inflateTransitionManager (int resource, 
                ViewGroup sceneRoot)
复制代码
```

#### 共享元素(ShareElement)

**共享元素**

一般是在关联的界面之前存在相同的(或者说类似的, 并不强制一定要相同)控件元素就会使用, 例如下图的按钮:

![img](https://user-gold-cdn.xitu.io/2018/5/30/163b0b8ca7704c06?imageslim)

A界面跳转要指定共享元素

```
        startActivity(new Intent(this, SecondActivity.class),
                ActivityOptionsCompat.makeSceneTransitionAnimation(this, mButton, "button")
                        .toBundle());
复制代码
```

B界面的布局文件中指定共享元素`android:transitionName="button"`

```
    <Button
        android:id="@+id/button2"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="第二个界面"
        android:transitionName="button"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        android:layout_marginTop="99dp"
        />
复制代码
```

可以看到所谓的共享元素即在两个界面的两个控件(或多个控件)之间的过渡变化效果

可以看到转场动画的操作都是针对Window对象, 拥有如下方法(同时都拥有对应的getter方法)

共享元素

```
void setSharedElementEnterTransition (Transition transition)
void setSharedElementExitTransition (Transition transition)
void setSharedElementReenterTransition (Transition transition)
void setSharedElementReturnTransition (Transition transition)
复制代码
```

#### 自定义Transiton

主要重写三个方法

1. 开始值
2. 结束值
3. 创建动画

[官方示例](https://gist.github.com/liangjingkanji/83d0091925cdc4e777968af199bba350)

Tip: 针对不同的View采用不同的动画效果可以重写Transition

#### 扩散(Propagation)

Propagation可以指定Transition中的视图过渡延迟, 控制进入当前场景的视图进入的先后顺序. 例如要求Explode动画中特定的View速度快于其他的视图.

##### 扩散中心

首先需要Transition确认扩散中心

```
void setEpicenterCallback (Transition.EpicenterCallback epicenterCallback)
复制代码
```

在Transiton.EpicenterCallback回调中需要重写以下方法

```
Rect onGetEpicenter (Transition transition)
复制代码
```

在回调方法内返回一个矩形, 其矩形的中心即扩散中心.

关系:

- TransitionPropagation 
  - VisibilityPropagation 
    - SidePropagation
    - CircularPropagation

通过transition的方法指定

```
void setPropagation (TransitionPropagation transitionPropagation) // 设置扩散

void setPropagationSpeed (float propagationSpeed) // 设置速度
复制代码
```

查看源码可以看到Explode默认使用的CircularPropagation

![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="954" height="226"></svg>)

Slide使用的自然是SlidePropagation

TransitionPropagation 属于抽象类提供三个重写方法

```
void captureValues (TransitionValues transitionValues)

String[] getPropagationProperties ()

long getStartDelay (ViewGroup sceneRoot, 
                Transition transition, 
                TransitionValues startValues, 
                TransitionValues endValues)
复制代码
```

分别控制:

1. 捕捉

示例

```
slide.setPropagation(new VisibilityPropagation() {
  @Override public long getStartDelay(ViewGroup sceneRoot, Transition transition,
                                      TransitionValues startValues, TransitionValues endValues) {
    return 0;
  }
});
复制代码
```

#### 路径动作

`PathMotion`是在api21引入的过渡动画的一种新的实现方式. 可以通过指定路径来限制动画运动轨迹

通过Transition设置路径动画

```
void setPathMotion (PathMotion pathMotion)
复制代码
```

PathMotion

- ArcMotion (弧形动作)
- PatternPathMotion

#### 弧形轨迹

共享元素都是在不同的界面间的位置变化是以直线运动的, 通过指定以下路径动作可以变成弧形轨迹

参考 GooglePlay 的实现效果

```
<changeBounds>
   <arcMotion android:minimumHorizontalAngle="15"
              android:minimumVerticalAngle="0"
              android:maximumAngle="90"/>
 </changeBounds>
复制代码
```

参数:

- android:maximumAngle

  ​	开始和结束的最大弧形角度

- android:minimumHorizontalAngle

  ​	两者接近水平的时候最小角度

- android:minimumVerticalAngle

  ​	垂直同上

#### 路径动作

可以完全自定义路径来控制共享元素的运动轨迹

```
<changeBounds>
     <patternPathMotion android:patternPathData="M0 0 L0 100 L100 100"/>
 </changeBounds>
复制代码
```

Tip: patternPathData 的参数值类似矢量动画

#### 自定义路径动作

```
 <changeBounds>
     <pathMotion class="my.app.transition.MyPathMotion"/>
 </changeBounds>
```



## 4.给我谈谈插值器 & 估值器 的作用



##### 简介：

 ![img](https://ask.qcloudimg.com/http-save/yehe-1001569/ahu0u0rfd4.png?imageView2/2/w/1620) 

 ![《Android必读之Android 动画种类详解》](http://47.100.55.132/wp-content/uploads/2019/05/16323c6ff4452ea6.png) 



#### 插值器

##### 简介

定义：是一个接口

作用：设置属性值，从初始值过渡到结束值得变化规律

 - 如匀速，加速&减速等

 - 确定了动画效果的变化的模式，如匀速变化，加速变化等

   

###### 应用场景：

实现非线性运动的动画效果   

>  非线性运动：动画改变的速率不是一成不变的，如加速 & 减速运动都属于非线性运动 



#### 1.3 具体使用

##### a. 设置方式

插值器在动画的使用有两种方式：在XML / Java代码中设置：

###### **设置方法1：在 动画效果的XML代码中设置插值器属性`android:interpolator`**

```javascript
<?xml version="1.0" encoding="utf-8"?>
<scale xmlns:android="http://schemas.android.com/apk/res/android"

    android:interpolator="@android:anim/overshoot_interpolator"
    // 通过资源ID设置插值器
    android:duration="3000"
    android:fromXScale="0.0"
    android:fromYScale="0.0"
    android:pivotX="50%"
    android:pivotY="50%"
    android:toXScale="2"
    android:toYScale="2" />
```

###### **设置方法2：在 Java 代码中设置**

```javascript
Button mButton = (Button) findViewById(R.id.Button);
        // 步骤1:创建 需要设置动画的 视图View

Animation alphaAnimation = new AlphaAnimation(1,0);
        // 步骤2：创建透明度动画的对象 & 设置动画效果

        alphaAnimation.setDuration(3000);
        Interpolator overshootInterpolator = new OvershootInterpolator();
        // 步骤3：创建对应的插值器类对象

        alphaAnimation.setInterpolator(overshootInterpolator);
        // 步骤4：给动画设置插值器

        mButton.startAnimation(alphaAnimation);
        // 步骤5：播放动画
```

- 那么使用插值器时的资源ID是什么呢？即有哪些类型的插值器可供我们使用呢？
- 下面将介绍 `Android`内置默认的插值器

##### b. 系统内置插值器类型

- `Android`内置了 9 种内置的插值器实现：

| 作用                                 | 资源ID                                           | 对应的Java类                     |
| :----------------------------------- | :----------------------------------------------- | :------------------------------- |
| 动画加速进行                         | @android:anim/accelerate_interpolator            | AccelerateInterpolator           |
| 快速完成动画，超出再回到结束样式     | @android:anim/overshoot_interpolator             | OvershootInterpolator            |
| 先加速再减速                         | @android:anim/accelerate_decelerate_interpolator | AccelerateDecelerateInterpolator |
| 先退后再加速前进                     | @android:anim/anticipate_interpolator            | AnticipateInterpolator           |
| 先退后再加速前进，超出终点后再回终点 | @android:anim/anticipate_overshoot_interpolator  | AnticipateOvershootInterpolator  |
| 最后阶段弹球效果                     | @android:anim/bounce_interpolator                | BounceInterpolator               |
| 周期运动                             | @android:anim/cycle_interpolator                 | CycleInterpolator                |
| 减速                                 | @android:anim/decelerate_interpolator            | DecelerateInterpolator           |
| 匀速                                 | @android:anim/linear_interpolator                | LinearInterpolator               |

使用时：

- 当在XML文件设置插值器时，只需传入对应的插值器资源ID即可
- 当在Java代码设置插值器时，只需创建对应的插值器对象即可  系统默认的插值器是`AccelerateDecelerateInterpolator`，即先加速后减速 
- 系统内置插值器的效果图：  

![img](https://ask.qcloudimg.com/http-save/yehe-1001569/snjqqr200h.gif)

- 使用`Android`内置的插值器能满足大多数的动画需求
- 如果上述9个插值器无法满足需求，还可以自定义插值器
- 下面将介绍如何自定义插值器（`Interpolator`）

##### c. 自定义插值器

- 本质：根据动画的进度（0%-100%）计算出当前属性值改变的百分比

- 具体使用：自定义插值器需要实现 

  ```
  Interpolator
  ```

   /

  ```
  TimeInterpolator
  ```

  接口 & 复写

  ```
  getInterpolation（）
  ```

  1. 补间动画 实现 `Interpolator`接口；属性动画实现`TimeInterpolator`接口  
  2. `TimeInterpolator`接口是属性动画中新增的，用于兼容`Interpolator`接口，这使得所有过去的`Interpolator`实现类都可以直接在属性动画使用

```javascript
// Interpolator接口
public interface Interpolator {  

    // 内部只有一个方法
     float getInterpolation(float input) {  
         // 参数说明
         // input值值变化范围是0-1，且随着动画进度（0% - 100% ）均匀变化
        // 即动画开始时，input值 = 0；动画结束时input = 1
        // 而中间的值则是随着动画的进度（0% - 100%）在0到1之间均匀增加

      ...// 插值器的计算逻辑

      return xxx；
      // 返回的值就是用于估值器继续计算的fraction值，下面会详细说明
    }  

// TimeInterpolator接口
// 同上
public interface TimeInterpolator {  

    float getInterpolation(float input);  

}  
```

在学习自定义插值器前，我们先来看两个已经实现好的系统内置差值器：

- 匀速插值器：`LinearInterpolator`
- 先加速再减速 插值器：`AccelerateDecelerateInterpolator`

```javascript
// 匀速差值器：LinearInterpolator
@HasNativeInterpolator  
public class LinearInterpolator extends BaseInterpolator implements NativeInterpolatorFactory {  
   // 仅贴出关键代码
  ...
    public float getInterpolation(float input) {  
        return input;  
        // 没有对input值进行任何逻辑处理，直接返回
        // 即input值 = fraction值
        // 因为input值是匀速增加的，因此fraction值也是匀速增加的，所以动画的运动情况也是匀速的，所以是匀速插值器
    }  


// 先加速再减速 差值器：AccelerateDecelerateInterpolator
@HasNativeInterpolator  
public class AccelerateDecelerateInterpolator implements Interpolator, NativeInterpolatorFactory {  
      // 仅贴出关键代码
  ...
    public float getInterpolation(float input) {  
        return (float)(Math.cos((input + 1) * Math.PI) / 2.0f) + 0.5f;
        // input的运算逻辑如下：
        // 使用了余弦函数，因input的取值范围是0到1，那么cos函数中的取值范围就是π到2π。
        // 而cos(π)的结果是-1，cos(2π)的结果是1
        // 所以该值除以2加上0.5后，getInterpolation()方法最终返回的结果值还是在0到1之间。只不过经过了余弦运算之后，最终的结果不再是匀速增加的了，而是经历了一个先加速后减速的过程
        // 所以最终，fraction值 = 运算后的值 = 先加速后减速
        // 所以该差值器是先加速再减速的
    }  


    }
```

- 从上面看出，自定义插值器的关键在于：**对input值 根据动画的进度（0%-100%）通过逻辑计算 计算出当前属性值改变的百分比**
- 下面我将用一个实例来说明该如何自定义插值器

#### 实例

- 目的：写一个自定义`Interpolator`：先减速后加速

步骤1：根据需求实现Interpolator接口  *DecelerateAccelerateInterpolator.java*

```javascript
/**
 * Created by Carson_Ho on 17/4/19.
 */

public class DecelerateAccelerateInterpolator implements TimeInterpolator {

    @Override
    public float getInterpolation(float input) {
        float result;
        if (input <= 0.5) {
            result = (float) (Math.sin(Math.PI * input)) / 2;
            // 使用正弦函数来实现先减速后加速的功能，逻辑如下：
            // 因为正弦函数初始弧度变化值非常大，刚好和余弦函数是相反的
            // 随着弧度的增加，正弦函数的变化值也会逐渐变小，这样也就实现了减速的效果。
            // 当弧度大于π/2之后，整个过程相反了过来，现在正弦函数的弧度变化值非常小，渐渐随着弧度继续增加，变化值越来越大，弧度到π时结束，这样从0过度到π，也就实现了先减速后加速的效果
        } else {
            result = (float) (2 - Math.sin(Math.PI * input)) / 2;
        }
        return result;
        // 返回的result值 = 随着动画进度呈先减速后加速的变化趋势
    }
```

} 

*MainActivity.java*

```javascript
 mButton = (Button) findViewById(R.id.Button);
        // 创建动画作用对象：此处以Button为例

        float curTranslationX = mButton.getTranslationX();
        // 获得当前按钮的位置

        ObjectAnimator animator = ObjectAnimator.ofFloat(mButton, "translationX", curTranslationX, 300,curTranslationX);
        // 创建动画对象 & 设置动画
        // 表示的是:
        // 动画作用对象是mButton
        // 动画作用的对象的属性是X轴平移
        // 动画效果是:从当前位置平移到 x=1500 再平移到初始位置
        animator.setDuration(5000);
        animator.setInterpolator(new DecelerateAccelerateInterpolator());
        // 设置插值器
        animator.start();
        // 启动动画
```

#### 效果图

![img](https://ask.qcloudimg.com/http-save/yehe-1001569/qohzdzgy0n.gif)

------

#### 2. 估值器（TypeEvaluator）

##### 2.1 简介

- 定义：一个接口
- 作用：设置 属性值 从初始值过渡到结束值 的变化具体数值   
  1. 插值器（`Interpolator`）决定 值 的变化规律（匀速、加速blabla），即决定的是变化趋势；而接下来的具体变化数值则交给    而估值器  
  2. 属性动画特有的属性

##### 2.2 应用场景

  协助插值器 实现非线性运动的动画效果   

>  非线性运动：动画改变的速率不是一成不变的，如加速 & 减速运动都属于非线性运动 

##### 2.3 具体使用

###### a. 设置方式

```javascript
ObjectAnimator anim = ObjectAnimator.ofObject(myView2, "height", new Evaluator()，1，3);
// 在第4个参数中传入对应估值器类的对象
// 系统内置的估值器有3个：
// IntEvaluator：以整型的形式从初始值 - 结束值 进行过渡
// FloatEvaluator：以浮点型的形式从初始值 - 结束值 进行过渡
// ArgbEvaluator：以Argb类型的形式从初始值 - 结束值 进行过渡
```

效果图

![img](https://ask.qcloudimg.com/http-save/yehe-1001569/7nnzi8bx2n.png?imageView2/2/w/1620)

![img](https://ask.qcloudimg.com/http-save/yehe-1001569/n4mhh84aee.png?imageView2/2/w/1620)

- 如果上述内置的估值器无法满足需求，还可以自定义估值器  下面将介绍如何自定义插值器（Interpolator）

###### b. 自定义估值器

- 本质：根据 插值器计算出当前属性值改变的百分比  & 初始值 & 结束值 来计算 当前属性具体的数值  如：动画进行了50%（初始值=100，结束值=200 ），那么匀速插值器计算出了当前属性值改变的百分比是50%，那么估值器则负责计算当前属性值 = 100 + （200-100）x50% = 150. 
- 具体使用：自定义估值器需要实现 TypeEvaluator接口 & 复写`evaluate()`

```javascript
public interface TypeEvaluator {  

    public Object evaluate(float fraction, Object startValue, Object endValue) {  
// 参数说明
// fraction：插值器getInterpolation（）的返回值
// startValue：动画的初始值
// endValue：动画的结束值

        ....// 估值器的计算逻辑

        return xxx；
        // 赋给动画属性的具体数值
        // 使用反射机制改变属性变化

// 特别注意
// 那么插值器的input值 和 估值器fraction有什么关系呢？
// 答：input的值决定了fraction的值：input值经过计算后传入到插值器的getInterpolation（），然后通过实现getInterpolation（）中的逻辑算法，根据input值来计算出一个返回值，而这个返回值就是fraction了
    }  
}  
```

在学习自定义插值器前，我们先来看一个已经实现好的系统内置差值器：浮点型插值器：`FloatEvaluator`

```javascript
public class FloatEvaluator implements TypeEvaluator {  
// FloatEvaluator实现了TypeEvaluator接口

// 重写evaluate()
    public Object evaluate(float fraction, Object startValue, Object endValue) {  
// 参数说明
// fraction：表示动画完成度（根据它来计算当前动画的值）
// startValue、endValue：动画的初始值和结束值
        float startFloat = ((Number) startValue).floatValue();  

        return startFloat + fraction * (((Number) endValue).floatValue() - startFloat);  
        // 初始值 过渡 到结束值 的算法是：
        // 1. 用结束值减去初始值，算出它们之间的差值
        // 2. 用上述差值乘以fraction系数
        // 3. 再加上初始值，就得到当前动画的值
    }  
}  
```

- 属性动画中的`ValueAnimator.ofInt（）` & `ValueAnimator.ofFloat（）`都具备系统内置的估值器，即`FloatEvaluator` & `IntEvaluator`     即系统已经默认实现了 **如何从初始值 过渡到 结束值 的逻辑**
- 但对于`ValueAnimator.ofObject（）`，从上面的工作原理可以看出并没有系统默认实现，因为对对象的动画操作复杂 & 多样，系统无法知道如何从初始对象过度到结束对象
- 因此，对于`ValueAnimator.ofObject（）`，我们需自定义估值器（`TypeEvaluator`）来告知系统如何进行从 初始对象 过渡到 结束对象的逻辑
- 自定义实现的逻辑如下

```javascript
// 实现TypeEvaluator接口
public class ObjectEvaluator implements TypeEvaluator{  

// 复写evaluate（）
// 在evaluate（）里写入对象动画过渡的逻辑
    @Override  
    public Object evaluate(float fraction, Object startValue, Object endValue) {  
        // 参数说明
        // fraction：表示动画完成度（根据它来计算当前动画的值）
        // startValue、endValue：动画的初始值和结束值

        ... // 写入对象动画过渡的逻辑

        return value;  
        // 返回对象动画过渡的逻辑计算后的值
    }  
```

#### 实例说明

- 下面我将用实例说明 该如何自定义`TypeEvaluator`接口并通过`ValueAnimator.ofObject（）`实现动画效果
- 实现的动画效果：一个圆从一个点 移动到 另外一个点  

![img](https://ask.qcloudimg.com/http-save/yehe-1001569/1jx7xeoc7v.gif)

- 工程目录文件如下：  

![img](https://ask.qcloudimg.com/http-save/yehe-1001569/yvb6133s76.png?imageView2/2/w/1620)

##### 步骤1：定义对象类

- 因为`ValueAnimator.ofObject（）`是面向对象操作的，所以需要自定义对象类。
- 本例需要操作的对象是 **圆的点坐标**  *Point.java*

```javascript
public class Point {

    // 设置两个变量用于记录坐标的位置
    private float x;
    private float y;

    // 构造方法用于设置坐标
    public Point(float x, float y) {
        this.x = x;
        this.y = y;
    }

    // get方法用于获取坐标
    public float getX() {
        return x;
    }

    public float getY() {
        return y;
    }
}
```

##### 步骤2：根据需求实现TypeEvaluator接口

- 实现`TypeEvaluator`接口的目的是自定义如何 从初始点坐标 过渡 到结束点坐标；
- 本例实现的是一个从左上角到右下角的坐标过渡逻辑。  

![img](https://ask.qcloudimg.com/http-save/yehe-1001569/1jx7xeoc7v.gif)

*PointEvaluator.java*

```javascript
// 实现TypeEvaluator接口
public class PointEvaluator implements TypeEvaluator {

    // 复写evaluate（）
    // 在evaluate（）里写入对象动画过渡的逻辑
    @Override
    public Object evaluate(float fraction, Object startValue, Object endValue) {

        // 将动画初始值startValue 和 动画结束值endValue 强制类型转换成Point对象
        Point startPoint = (Point) startValue;
        Point endPoint = (Point) endValue;

        // 根据fraction来计算当前动画的x和y的值
        float x = startPoint.getX() + fraction * (endPoint.getX() - startPoint.getX());
        float y = startPoint.getY() + fraction * (endPoint.getY() - startPoint.getY());

        // 将计算后的坐标封装到一个新的Point对象中并返回
        Point point = new Point(x, y);
        return point;
    }

}
```

- 上面步骤是根据需求自定义`TypeEvaluator`的实现
- 下面将讲解如何通过对 `Point` 对象进行动画操作，从而实现整个自定义View的动画效果。

##### 步骤3：将属性动画作用到自定义View当中

*MyView.java*

```javascript
/**
 * Created by Carson_Ho on 17/4/18.
 */
public class MyView extends View {
    // 设置需要用到的变量
    public static final float RADIUS = 70f;// 圆的半径 = 70
    private Point currentPoint;// 当前点坐标
    private Paint mPaint;// 绘图画笔


    // 构造方法(初始化画笔)
    public MyView(Context context, AttributeSet attrs) {
        super(context, attrs);
        // 初始化画笔
        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
        mPaint.setColor(Color.BLUE);
    }

    // 复写onDraw()从而实现绘制逻辑
    // 绘制逻辑:先在初始点画圆,通过监听当前坐标值(currentPoint)的变化,每次变化都调用onDraw()重新绘制圆,从而实现圆的平移动画效果
    @Override
    protected void onDraw(Canvas canvas) {
        // 如果当前点坐标为空(即第一次)
        if (currentPoint == null) {
            currentPoint = new Point(RADIUS, RADIUS);
            // 创建一个点对象(坐标是(70,70))

            // 在该点画一个圆:圆心 = (70,70),半径 = 70
            float x = currentPoint.getX();
            float y = currentPoint.getY();
            canvas.drawCircle(x, y, RADIUS, mPaint);


 // (重点关注)将属性动画作用到View中
            // 步骤1:创建初始动画时的对象点  & 结束动画时的对象点
            Point startPoint = new Point(RADIUS, RADIUS);// 初始点为圆心(70,70)
            Point endPoint = new Point(700, 1000);// 结束点为(700,1000)

            // 步骤2:创建动画对象 & 设置初始值 和 结束值
            ValueAnimator anim = ValueAnimator.ofObject(new PointEvaluator(), startPoint, endPoint);
            // 参数说明
            // 参数1：TypeEvaluator 类型参数 - 使用自定义的PointEvaluator(实现了TypeEvaluator接口)
            // 参数2：初始动画的对象点
            // 参数3：结束动画的对象点

            // 步骤3：设置动画参数
            anim.setDuration(5000);
            // 设置动画时长

// 步骤3：通过 值 的更新监听器，将改变的对象手动赋值给当前对象
// 此处是将 改变后的坐标值对象 赋给 当前的坐标值对象
            // 设置 值的更新监听器
            // 即每当坐标值（Point对象）更新一次,该方法就会被调用一次
            anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
                @Override
                public void onAnimationUpdate(ValueAnimator animation) {
                    currentPoint = (Point) animation.getAnimatedValue();
                    // 将每次变化后的坐标值（估值器PointEvaluator中evaluate（）返回的Piont对象值）到当前坐标值对象（currentPoint）
                    // 从而更新当前坐标值（currentPoint）

// 步骤4：每次赋值后就重新绘制，从而实现动画效果
                    invalidate();
                    // 调用invalidate()后,就会刷新View,即才能看到重新绘制的界面,即onDraw()会被重新调用一次
                    // 所以坐标值每改变一次,就会调用onDraw()一次
                }
            });

            anim.start();
            // 启动动画


        } else {
            // 如果坐标值不为0,则画圆
            // 所以坐标值每改变一次,就会调用onDraw()一次,就会画一次圆,从而实现动画效果

            // 在该点画一个圆:圆心 = (30,30),半径 = 30
            float x = currentPoint.getX();
            float y = currentPoint.getY();
            canvas.drawCircle(x, y, RADIUS, mPaint);
        }
    }


}
```

##### 步骤4：在布局文件加入自定义View空间

*activity_main.xml*

```javascript
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:paddingBottom="@dimen/activity_vertical_margin"
    android:paddingLeft="@dimen/activity_horizontal_margin"
    android:paddingRight="@dimen/activity_horizontal_margin"
    android:paddingTop="@dimen/activity_vertical_margin"
    tools:context="scut.carson_ho.valueanimator_ofobject.MainActivity">

    <scut.carson_ho.valueanimator_ofobject.MyView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
         />
</RelativeLayout>
```

##### 步骤5：在主代码文件设置显示视图

*MainActivity.java*

```javascript
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }
}
```

#### 效果图

![img](https://ask.qcloudimg.com/http-save/yehe-1001569/1jx7xeoc7v.gif)

### 5.说说Android动画框架实现的原理。

现有的 Android 动画框架是建立在 View 的级别上的，在 View 类中有一个接口 startAnimation 来使动画开始，startAnimation 函数会将一个 Animation 类别的参数传给 View，这个 Animation 是用来指定我们使用的是哪种动画，现有的动画有平移，缩放，旋转以及 alpha 变换等。如果需要更复杂的效果，我们还可以将这些动画组合起来，这些在下面会讨论到。

要了解 Android 动画是如何画出来的，我们首先要了解 Android 的 View 是如何组织在一起，以及他们是如何画自己的内容的。每一个窗口就是一棵 View 树，下面以我们写的 android_tabwidget_tutorial.doc 中的 tab 控件的窗口为例，通过 android 工具 hierarchyviewer 得到的窗口 View Tree 如下图 1 所示：
 ![界面 View 结构图](http://www.ibm.com/developerworks/cn/opensource/os-cn-android-anmt1/1.jpg) 

 ![界面 View 结构和显示对应图图](http://www.ibm.com/developerworks/cn/opensource/os-cn-android-anmt1/2.jpg) 



RootView 只有一个孩子就是 DecorView，这里整个 View Tree 都是 DecorView 的子 View。

- 在DecorView中，标题窗口（TitleBar）以下部分的 FrameLayout(Content容器) 就是为了让程序员通过 setContentView 来设置用户需要的窗口内容。

- 因为整个 View 的布局就是一棵树，所以绘制的时候也是按照树形结构遍历来让每个 View 进行绘制。



递归的绘制整个窗口需要按顺序执行以下几个步骤：

- 绘制背景；
- 如果需要保存画布（canvas）的层，为淡入或淡出做准备；
- 绘制 View 本身的内容：通过调用 View.onDraw(canvas) 函数实现，通过这个我们应该能看出来 onDraw 函数重载的重要性，onDraw 函数中绘制线条 / 圆 / 文字等功能会调用 Canvas 中对应的功能。（每个View都需要重载该方法，ViewGroup不需要实现该方法）如果该view是ViewGroup，则需要绘制自己的孩子：通过 dispatchDraw(canvas) 实现，参看 ViewGroup.Java 中的代码可知，dispatchDraw()   ->   drawChild()   ->   child.draw(canvas) 。这样的调用过程被用来保证每个子 View 的 draw 函数都被调用，通过这种递归调用从而让整个 View 树中的所有 View 的内容都得到绘制。（在调用每个子 View 的 draw 函数之前，需要绘制的 View 的绘制位置是在 Canvas 通过 translate 函数调用来进行切换的，窗口中的所有 View 是共用一个 Canvas 对象。）
- 如果需要，我们可以绘制淡入淡出相关的内容，并恢复保存的画布所在的层（layer）
- 绘制修饰的内容（例如滚动条）:这个可知要实现滚动条效果并不需要 ScrollView，可以在 View 中完成的，比如通过ParentView中设置ChildView的画布来调整Canvas，进而实现动画效果(安卓动画就是通过父View来不断调整子View的画不坐标系来实现的)
  

当一个 ChildView 要重画时，它会调用其成员函数 invalidate() 函数将通知其 ParentView 这个 ChildView 要重画，这个过程一直向上遍历到 ViewRoot，当 ViewRoot 收到这个通知后就会调用上面提到的 ViewRoot 中的 draw 函数从而完成绘制。View::onDraw() 有一个画布参数 Canvas, 画布顾名思义就是画东西的地方，Android 会为每一个 View 设置好画布，View 就可以调用 Canvas 的方法，比如：drawText, drawBitmap, drawPath 等等去画内容。每一个 ChildView 的画布是由其 ParentView 设置的，ParentView 根据 ChildView 在其内部的布局来调整 Canvas，其中画布的属性之一就是定义和 ChildView 相关的坐标系，默认是横轴为 X 轴，从左至右，值逐渐增大，竖轴为 Y 轴，从上至下，值逐渐增大 , 见下图 :


图 4. 窗口坐标系

Android 动画就是通过 ParentView 来不断调整 ChildView 的画布坐标系来实现的，下面以平移动画来做示例，见下图 4，假设在动画开始时 ChildView 在 ParentView 中的初始位置在 (100,200) 处，这时 ParentView 会根据这个坐标来设置 ChildView 的画布，在 ParentView 的 dispatchDraw 中它发现 ChildView 有一个平移动画，而且当前的平移位置是 (100, 200)，于是它通过调用画布的函数 traslate(100, 200) 来告诉 ChildView 在这个位置开始画，这就是动画的第一帧。如果 ParentView 发现 ChildView 有动画，就会不断的调用 invalidate() 这个函数，这样就会导致自己会不断的重画，就会不断的调用 dispatchDraw 这个函数，这样就产生了动画的后续帧，当再次进入 dispatchDraw 时，ParentView 根据平移动画产生出第二帧的平移位置 (500, 200)，然后继续执行上述操作，然后产生第三帧，第四帧，直到动画播完。具体算法描述如清单 2：

清单 2. 算法

 dispatchDraw() 
 { 
 .... 
 Animation a = ChildView.getAnimation() 
 Transformation tm = a.getTransformation(); 
 Use tm to set ChildView's Canvas; 
 Invalidate(); 
 .... 
 } 


图 5. 平移动画示意图

以上是以平移动画为例子来说明动画的产生过程，这其中又涉及到两个重要的类型，Animation 和 Transformation，这两个类是实现动画的主要的类，Animation 中主要定义了动画的一些属性比如开始时间、持续时间、是否重复播放等，这个类主要有两个重要的函数：getTransformation 和 applyTransformation，在 getTransformation 中 Animation 会根据动画的属性来产生一系列的差值点，然后将这些差值点传给 applyTransformation，这个函数将根据这些点来生成不同的 Transformation，Transformation 中包含一个矩阵和 alpha 值，矩阵是用来做平移、旋转和缩放动画的，而 alpha 值是用来做 alpha 动画的（简单理解的话，alpha 动画相当于不断变换透明度或颜色来实现动画），以上面的平移矩阵为例子，当调用 dispatchDraw 时会调用 getTransformation 来得到当前的 Transformation，这个 Transformation 中的矩阵如下：


图 6. 矩阵变换图

所以具体的动画只需要重载 applyTransformation 这个函数即可，类层次图如下：


图 7. 动画类继承关系图

用户可以定义自己的动画类，只需要继承 Animation 类，然后重载 applyTransformation 这个函数。对动画来说其行为主要靠差值点来决定的，比如，我们想开始动画是逐渐加快的或者逐渐变慢的，或者先快后慢的，或者是匀速的，这些功能的实现主要是靠差值函数来实现的，Android 提供了 一个 Interpolator 的基类，你要实现什么样的速度可以重载其函数 getInterpolation，在 Animation 的 getTransformation 中生成差值点时，会用到这个函数。

从上面的动画机制的分析可知某一个 View 的动画的绘制并不是由他自己完成的而是由它的父 view 完成，所有我们要注意上面 TextView 旋转一周的动画示例程序中动画的效果并不是由 TextView 来绘制的，而是由它的父 View 来做的。findViewById(R.id.TextView01).startAnimation(anim) 这个代码其实是给这个 TextView 设置了一个 animation，而不是进行实际的动画绘制，代码如下 :

public void startAnimation(Animation animation) { animation.setStartTime(Animation.START_ON_FIRST_FRAME); setAnimation(animation); invalidate(); }

其他的动画机制的代码感兴趣的读者请自己阅读，希望通过原理的讲解以后看起来会轻松点，呵呵。

以上就是 Android 的动画框架的原理，了解了原理对我们的开发来说就可以清晰的把握动画的每一帧是怎样生成的，这样便于开发和调试。它把动画的播放 / 绘制交给父 View 去处理而不是让子 View 本身去绘制，这种从更高的层次上去控制的方式便于把动画机制做成一个易用的框架，如果用户要在某个 view 中使用动画，只需要在 xml 描述文件或代码中指定就可以了，从而把动画的实现和 View 本身内容的绘制（象 TextView 里面的文字显示）分离开了，起到了减少耦合和提高易用性的效果。

