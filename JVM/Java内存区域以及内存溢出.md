[TOC]

<font size=1>

![image](https://segmentfault.com/img/bVRQWS)

# Java内存区域以及内存溢出:




## 运行时数据区
&nbsp;
![image](https://user-gold-cdn.xitu.io/2019/11/22/16e90eacc75aad24?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

![](https://img-blog.csdn.net/20141013141216040)

运行数据区分为五个主要的模块：

### 程序计数器

![image-20200229204020680](Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%BB%A5%E5%8F%8A%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA.assets/image-20200229204020680.png)

![image-20200229204042500](Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%BB%A5%E5%8F%8A%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA.assets/image-20200229204042500.png)

- 线程**私有**，各个线程之间互不影响
- 在任何一个确定的时刻，**一个处理器都只会执行一条线程中的指令**。
- 该区域是一块较小的内存空间，**可以看做是当前线程所执行的字节码的行号指示器**。
- 如果正在执行**Java方法**，计数器记录的是**正在执行的虚拟机字节码指令地址**
- 如果是一个**native方法**，则**计数器值为空**(native方法指的是Java程序调用了非Java代码，算是一种引入其他语言程序的接口)
- **生命周期随着线程的启动而产生，随着其结束而死亡**
- **唯一一个在Java虚拟机规范中没有规定任何OutOfMemeryError的情况**。 
- 在虚拟界的概念模型里，字节码解释器工作室就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支，跳转，循环，异常出理，线程恢复等基础功能都需要依赖这个计数器来完成。

>Java虚拟机的多线程就是通过线程轮流切换并分配处理器执行事件的方式来实现的，在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令。因此，**为了线程切换后能够恢复到正确的执行位置，每天线程都需要一个独立的程序计数器**，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。

&nbsp;
### Java虚拟机栈

![image-20200229203808099](Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%BB%A5%E5%8F%8A%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA.assets/image-20200229203808099.png)

![](https://img-blog.csdn.net/20141117164047783)

- 线程私有，且生命周期与线程相同。
- 每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程
- 虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的过程中都会创建一个栈帧，用于存储  **局部变量表，操作数栈，动态链接，方法出口等信息**。
 - 一般所言，**java内存区分为堆内存和栈内存，此处的栈指的就是或者说是Java虚拟机栈中的局部变量表部分。**
- 局部变量表存放了编译期可知的各种基本数据类型(8种)，对象引用(reference类型，他不等同于对象本身，可能是一个只想对象起始位置的引用指针，也可能是直系那个一个代表对象的句柄或者其他与对象相关的位置)以及returnAddress类型(执行了一条字节那指令的地址)
> 其中64位长度的long和double类型的数据都会占用两个局部变量的空间，其他只有一个。且局部变量表所需要的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

<font size=3>**栈帧**</font>

![](https://img-blog.csdn.net/20141013142638909)

1. **局部变量表：** 32位变量槽，存放了编译期可知的各种基本数据类型，对象引用，retrunAddress类型
2. **操作数栈：** 基于栈的执行引擎，虚拟机把操作数栈作为他们的工作区，大多数指令都要从这里弹出数据，执行运算，然后将结果压回操作数栈
3. **动态链接：** 每个栈帧都包括一个执行运行时常量池中该栈帧所属方法的引用。持有这个引用是为了支持方法调用过程中的动态链接。Class文件的常量池中大量的符号引用，字节码中的方法调用执零就是以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用过，这种转化成为静态解析。另一部分将在每一次的运行期间转化为直接应用，成为动态连接
4. **方法出口：** 返回方法被调用的位置，回复上层方法的局部变量和操作数栈，如果没有返回值，则将其压入调用者的操作数栈

> - 局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的。
> - 在方法运行期间不会改变局部变量表的大小。主要存放了编译期可知的各种基本数据类型、对象引用 （reference类型）、returnAddress类型）。

java虚拟机栈,规定了两种异常状况：

&nbsp;

- 如果线程请求的深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。
- 如果虚拟机栈动态扩展，而扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。

### 本地方法栈

![image-20200229203859991](Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%BB%A5%E5%8F%8A%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA.assets/image-20200229203859991.png)

- 与虚拟机栈所发挥的作用十分相似，之间的区别在于虚拟机栈为虚拟机执行Java方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的Native方法服务。
- 虚拟机规范中并没有对本地方法栈中使用的语言，使用方法以及数据结构进行强制的规定，甚至已于有些虚假你急就直接将两者合二为一。
- 与虚拟机栈一样，会抛出StackOverFlowError以及OutOfMemoryError异常。

### Java堆

![image-20200229203918283](Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%BB%A5%E5%8F%8A%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA.assets/image-20200229203918283.png)

- <font size=2>Java虚拟机所管理的内存中的最大的一块内存区域。该区域被所有的线程共享，在虚拟机启动时创建
- 这块内存区域的主要作用就是存放对象实例，几乎所有的对象实例都在此分配内存。
- Java堆是垃圾收集器管理的主要区域，因此很多时候也被称为"GC堆"
- (为了更好的回收和分配内存)**从内存回收角度来看，由于收集器采用的是分代收集算法，所以Java堆也可以分为新生代和老年代，再细致的可以分为：Eden空间，From Survivor空间，To Survivor空间等。**
- 从内存分配角度来看，**Java堆中可能划分出多个线程私有的分配缓冲区域(TLAB，Thread Local Allocationy Buffer)。**
- Survivor空间等Java堆可以处在物理上不连续的内存空间中，只要逻辑上是连续的即可（就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的）。

> 不论如何划分，都与存放的内容无关，无论哪个区域，存放的都是对象实例，而进一步划分的目的是为了更好的回收内存，或者是更快的回收内存。

- 根据Java虚拟机规范的规定，Java堆可以处于物理上的不连续的内存空间中，只要逻辑上是连续的即可。而实现的时候既可以是固定大小的，也可以是可扩展的，不过当前主流的虚拟机大多蚕蛹的是可扩展来实现的。而如果在堆中没有内存完成实例分配，并且堆也无法在扩展时，将会抛出OutOfMemoryError异常。

### 方法区

![image-20200229203937005](Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%BB%A5%E5%8F%8A%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA.assets/image-20200229203937005.png)

![](https://img-blog.csdn.net/20141013142924359)

- 和Java堆一样，是各个线程共享的内存区域，用于存储已经被虚拟机加载的类信息，常量，静态变量，即编译器编译后的代码等数据
- 虽然Java虚拟机规范将方法区描述为堆的一部分，但是他的别名叫做：Non_Heap(非堆)，目的是为了与Java堆区分开来。
- 习惯在HotSpot虚拟机上开发部署的开发者来说，习惯于将方法区成为“永久代”，而JDK1.7中将原来放在永久代中的字符串常量池移动到了堆中。 
- 如何实现发放区，属于虚拟机的实现细节，不受虚拟机规范约束
- Java虚拟机规范对方法区的管理特别宽松，除了和堆一样不需要连续的内存空间和可以选择的固定大小或者可扩展外，还可以选择不实现垃圾收集。
- 方法区的内存回收主要是针对常量池的回收和类型的卸载，一般来说，这块区域的回收成绩很难令人满意，尤其是类型卸载。
- 方法区主要存放的是Java类定义信息，与垃圾回收关系不大，方法区可以选择不是实现垃圾回收，但是不是没有垃圾回收
- 方法区的内存回收主要针对的是常量池的回收和对类型的卸载
- 运行时常量池也是方法区的一部分，虚拟机加载Class后将常量池的数据放入运行时常量池
- 当方法区无法满足内存分配需求之时，将抛出OutOfMemoryError异常。

#### 运行时常量池

- 是方法区的一部分，Class文件中除了有类的版本，字段，方法，接口等描述信息之外，还有意向信息是常量池，用于**存放编译器产生的各种字面量和符号引用，而该部分将会在类加载之后进入方法区的运行时常量池中存放。**
- Java虚拟机对于Class文件的每一部分的各式要求的都比较严格，每个字节用于存储那种数据都必须符合规范上的要求才会被虚拟机认可，装载和执行，但是对于运行时常量池，Java虚拟机规范没有做任何细节的要求。
- 除了保存Class文件描述的符号引用之外，还会把编译出来的直接引用保存在此块内存区域。
- 运行时常量池相对于Class文件常量池的另一个重要的特征就是具备动态性，Java语言并不要求常量一定只有在便一起才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区的运行时常量池，运行期间也可能将新的常量放入池中，而此特性被运用的最多的就是String类的intern()方法。
- 因为是方法区的一部分，所以会受到方法区内存的限制，当常量池无法在申请到内存时将会抛出OutOfMemoryError异常。

1. 常量池（Constant Pool）：**常量池数据编译期被确定，是Class文件中的一部分。存储了类、方法、接口等中的常量，当然也包括字符串常量。**
2. 字符串池/字符串常量池（String Pool/String Constant Pool）：是常量池中的一部分，存储编译期类中产生的字符串类型数据。
3. 运行时常量池（Runtime Constant Pool）：方法区的一部分，所有线程共享。虚拟机加载Class后把常量池中的数据放入到运行时常量池。常量池：可以理解为Class文件之中的资源仓库，它是Class文件结构中与其他项目资源关联最多的数据类型。

常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic Reference）。
- 字面量：文本字符串、声明为final的常量值等；。
- 符号引用：类和接口的完全限定名（Fully Qualified Name、字段的名称和描述符（Descriptor）、方法的名称和描述符。

** JDK1.6之前字符串常量池位于方法区之中。**
** JDK1.7字符串常量池已经被挪到堆之中。**


### 直接内存

- **并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁调用，而且可以导致OutOfMemoryError异常出现。**
- 在JDK1.4中新加入了(New Inout/Output)类，引入了一种基于通道(Channel)与缓冲区(Buffer)的I/O方式，他可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectDByteBuffer对象作为这块内存的引用进行操作。这样可以在一这些场景中显著提改性能，因为避免了Java堆和Native堆中来回复制数据。
- 本机直接内存的分配不会受到Java堆大小的限制，但是既然是内存，肯定会受到本机总内存的大小以及处理器寻址空间的限制。
- 服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存区域和大于物理内存限制(包括无力的和操作系统级的限制)，从而导致动态扩展时出现OutOfMemoryError异常。


# HotSpot虚拟机对象
## 对象创建

- **主要探讨HotSpot虚拟机在Java堆中对象分配，布局和访问的全过程**
- **虚拟机遇到new指令时**


在Java程序运行过程中，无时无刻都有对象被创建出来。在语言层面上，创建一个对象通常仅仅是一个new关键字而已，而在虚拟机中，对象(文中讨论的限于普通的Java对象，不包括数组和Class对象)的创建过程如下：
1.  **虚拟机遇到一个new指令的时候，将会首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查 这个符号引用代表的类是否已经被加载，解析和初始化过。如果没有，则必须先执行相应的类加载过程。**
2.  加载检查通过后，分配内存（内存在类加载完成后便可完全确定）。
3.  内存分配完成后，虚拟机对对象进行必要的设置，如对象是哪个类的实例、如何找到类的元数据信息等(都放在对象的对象头中)。
4.  从虚拟机角度看，一个新的对象产生了，但从java程序视角看，对象创建才刚刚开始，因为<init>方法还没有执行，，所有字段为零。执行new指令之后会接着执行<init>方法（构造方法），进行初始化，这样一个真正可用的对象才算完成产生。
    

在类加载检查通过之后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成之后便可完全确定下来，为对象分配空间的任务相当于把一块确定大小的内存从Java堆中划分出来。


### 指针碰撞

> 假设Java堆中内存时绝对规整的，所有用过的内存都放在一边，空闲的指针放在另一边，中间放着一个指针作为分界点的指示器，那所分配的内存就仅仅是把那个这个指向空闲列表的那边挪动一段与对象大小想等的距离

### 空闲列表

> 如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存互相交错，那就没有办法进行简单的指针碰撞了。所以Java虚拟机就必须维护一个列表，记录那些内存相互交错，再分配的时候从列表中找到一块足够大的额空间划分给对象实例，并更新列表上的记录。

> 选择那种分配方式是由Java堆是否规整决定，
> 而Java堆是否规整又由所在用的垃圾收集器是否带有压缩整理功能决定。因此，在使用Serial,ParNew等带Compat过程的收集器是，系统采用的分配算发是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。


除了解决如何划分空间之外，还有一个需要考虑的问题就是对象创建在虚拟机中是非常频繁的操作，即使仅仅修改一个指针的指向位置，在并发情况下，可能出现正在给对象A分配内存，指针还没有来得及修改，而对象B又同时使用的原来的指针来分配内存的情况，而解决该问题有两个方案
- 针对分配内存的空间的动作进行同步代理，实际上是虚拟机采用CAS配上失败重试的方式保证更新操作的原子性，
- 把内存分配的动作按照线程划分在不同的空间中进行，即每个线程在Jav堆中预先分配一小块内存空间，成为本地线程分配缓冲(TLAB)，那个线程要分配内存，就在那个线程的TALB上分配，只有TALB用完之后并分配新的TALB的时候，才需要同步锁定。而虚拟机是否使用TALB,可以通过-XX:+/-UserTALB参数锁定。

内存分配完成之后，虚拟机需要将分配到的内存空hi教案全都初始化为零值(不包括对象头)，如果使用TALB,这个工作过程可以提前到TALB分配时进行。这一步操作保证了对象的实例字段在Java代码中可以不附初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

接下来，虚拟机要对对象进行必要操设定，比如这个对象是那个类的实例，如何才能找到类的元数据信息，对象的哈希码，对象的GC分代年龄等信息。这些信息存放在对象的对象头中。根据虚拟机当前的运行状态的不同，如是否都启用偏向锁等，对象头会有不同的设置方式。
上面的工作完成之后，从虚拟机角度来看，一个新的对象已经产生，但从Java程序的视角来看，对象的创建刚刚开始————<init>方法还没有执行，所有的字段都是零。所以一般来说，执行newn指令之后会接着执行<init>方法，把对象按照程序员的设定进行初始化，这样对象的初始化才算完成。

## 对象的内存布局

在HotSpot虚拟机中，对象在内存中存储的布局有三种：**对象头(Head),实例数据(Instance Data)以及对其补充(Padding)。**

- HotSpot虚拟机的对象头包括两个部分：
  -  第一部分用于存储对象自身的**运行时数据**，如**哈希码(HashCode)，GC分代年龄,锁状态标志,线程持有的锁，偏向线程ID,偏时间戳等**，这部分在32位以及64位的虚拟机中分别是32bit和64bit,官方称他为“Mark Word”。对象需要存储的运行时数据很多，已经超出了Bitmap结构所能记录的限度，但是对象头信息与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计为一个非固定的数据结构以便在极小的空间存储最多的信息。
  -  另一部分是类型指针，即对象指向他的类元数据，虚拟机通过这个指针来确定对象是属于哪个了类。<font color=red>查找对象的元数据信息不一定要经过对象本身</font>。
  
> 如果对象是一个数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通的Java对象的元数据却低估Java对象的大小，但是数组的元数据中却无法确定数组的大小。

- 实例数据（InstanceData）
    对象真正存储的有用信息，也是程序中定义的各种类型的字段内容。
- 对齐填充（Padding）
    由于HotSpot虚拟机要求对象的起始地址必须是8字节的整数倍，通俗的说，就是对象大小必须是8字节的整数倍。对象头正好是8字节的倍数。当实例数据部分没有对齐时，需要通过对齐填充来补全。
## 几种常见的内存溢出

## 对象的访问定位

Java程序通过栈上的reference数据来操作堆上的具体对象。
不同虚拟机实现的对象访问方式会有所不同，目前主流的访问方式有两种：使用句柄和直接指针。
使用句柄 是间接访问，优点是reference中存储的是稳定的句柄地址，对象移动时只会改变句柄中的实例数据指针。
使用直接指针 是直接访问，优点就是速度快。
### Java堆溢出

Java堆用于存储对象的实例，只要不断地创建对象，并且保证GC Roots 到对象之间有可达路径来避免垃圾回收机制清楚这些对象，那么在对象数量达到最大堆的容量限制后就会产生内存溢出异常

代码清单2-3中代码限制Java堆的大小为20MB,不可扩展，通过参数-XX:+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出异常时Dump出当前的内存堆转储快照以便事后进行分析

Java堆内存的OOM异常是实际应用中常见的内存溢出异常情况。当出现Java堆内存溢出时，异常堆栈信息“java.lang.OutOfMemoryError”会跟着进一步提示"Java heap space".

要解决这个区域的异常，一般的手段是先通过内存映像分析工具对Dump出来的堆转出快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏还是内存溢出

- 如果是内存泄漏，可进一步的通过工具查看泄漏对象到GC Roots的引用链，于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾回收集器无法自动关机回收他们的。掌握了泄漏对象的类型信息及GC Roots引用链的信息，就可以比较准确的定位泄漏代码的位置
- 如果不存在泄漏，就是内存中的对象确实是还必须存活着，那就应当检查虚拟机的堆参数(-Xmx与-Xms)，与机器物理内存对比看是否还可以调大，从代码中检查是否存在某些对象生命周期过长，持有状态事件过长的情况，尝试减少程序运行期的内存消耗。

    ![image](https://segmentfault.com/img/bVRQWU)

