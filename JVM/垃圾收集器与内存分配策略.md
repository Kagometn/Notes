## 垃圾收集器与内存分配策略



#### 为什么了解GC和内存分配？

尽管目前的内存的动态分配与内存回收技术十分的成熟，但是当需要排查各种内存溢出，内存泄漏问题时，当垃圾回收已经达到了更高的并发量的瓶颈的时候。就需要对这些“自动化”的技术试试必要的监控和调解。

#### 一，学习目标：

1.对象存活判断

2.GC（garbage collection）算法学习

3.垃圾回收器

4.内存分配与回收策略

对于GC学习,我们主要考虑三个问题：哪些内存需要回收 -> 什么时候回收 -> 如何回收

#### 二，那些内存需要回收

内存运行时，程序计数器、本地方法栈和虚拟机栈是随着线程的产生而产生，随着线程的消亡而消亡的，这几部分的内存分配和回收是确定好了的，随方法结束或线程结束时，内存就紧跟着回收了。而Java堆和方法区不一样。一个接口中多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在运行期间才知道会创建哪些对象，故内存回收与分配重点关注的是**堆内存**和**方法区内存。**

#### 三，什么时候回收(判断对象的存活)

**对于方法区**，永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。

**对于堆**，其中存放的是对象实例，对于对象实例的回收，我们首先要判断哪些对象是“存活的”，对于那部分“死亡的”对象，就是我们要回收的。判断对象的存活有两种方法：

- **引用计数算法**
- **可达性分析算法**

**引用计数算法**：给对象添加一个引用计数器, 每当有一个地方引用它时, 计数器值+1, 引用失效, -1, 为0的对象不能被使用。

- 优势：实现简单，效率高。
- 缺点：无法解决对象<font color = Red​>**相互引用**</font>的问题——会导致对象的引用虽然存在，但是已经不可能再被使用，却无法被回收。

**可达性分析算法**：通过一系列的称为”GC Roots”的对象作为起始点, 从这些节点开始向下搜索, 搜索走过的路径称为引用链(Reference Chain), 当一个对象到GC Roots不可达(也就是不存在引用链)的时候, 证明对象是不可用的。如下图: *Object5、6、7* 虽然互有关联, 但它们到GC Roots是不可达的, 因此也会被判定为可回收的对象。（注意：不可达的对象, VM也并不是马上对其回收, 因为要真正宣告一个对象死亡, 至少要经历两次标记）

![](https://upload-images.jianshu.io/upload_images/13202633-2e77a2e3f0833cf8.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

 

在Java, 可作为GC Roots的对象包括：

- 方法区: 类静态属性引用的对象;
- 方法区: 常量引用的对象;
- 虚拟机栈(本地变量表)中引用的对象.
- 本地方法栈JNI(Native方法)中引用的对象。

#### **四.如何回收**

##### **垃圾收集算法**

###### 1.标记清除算法

  **分为标记和清除两个阶段**，先标记出需要回收的对象（可达性分析算法或者引用计数算法），在标记完成后统一回收所有被标记的对象。

  **不足之处**：

- **效率问题**，标记和清除效率都不高。
- **空间问题**，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾回收动作。

![](https://upload-images.jianshu.io/upload_images/13202633-9f81e7c7bdb74970.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

###### 2.复制算法

目的：为了解决效率问题

  将可用内存划分为大小相等的两块，每次只使用其中的一块。当这块用完了，就将还存活的复制到另一块上，然后将这一块一次性清除。商业虚拟机都是采用该方法来回收新生代，新生代98%都是朝生夕死的。将内存分为较大Eden和两个较小的survivor空间。每次使用其中一块Eden和survivor，回收时将存活的对象一次性地复制到另一块survivor中，再清理掉之前的。HotSpot虚拟机Eden与Survivor默认的大小比例为8:1:1。survivor空间不够时，需要依赖其他内存（老年代）进行分配担保，即让对象进入老年代。



![img](https:////upload-images.jianshu.io/upload_images/13202633-d4e0d6f229232038.png?imageMogr2/auto-orient/strip|imageView2/2/w/577/format/webp)



不足：将内存缩小为原来的一半，如果有大量内存较大的对象时会引起频繁的GC

应用：

目前大多数的商业虚拟机使用此回收算法收集**新生代**，

###### 3.标记整理算法

  **复制算法在对象存活率较高时效率很低**。根据老年代的特点提出该算法。标记过程同标记清除一样，但不是直接对可回收对象进行清理，而是让存活对象朝着一端移动，然后直接清理掉端边界外的内存。



![img](https:////upload-images.jianshu.io/upload_images/13202633-a7cba21534330488.png?imageMogr2/auto-orient/strip|imageView2/2/w/574/format/webp)



###### 4.分代收集算法

  根据各年代特点分别采用最适当的GC算法。在新生代:中每次垃圾收集都能发现大批对象已死, 只有少量存活. 因此选用复制算法, 只需要付出少量存活对象的复制成本就可以完成收集。在老年代: 因为对象存活率高、没有额外空间对它进行分配担保, 就必须采用**“**标记—清理**”**或**“**标记—整理**”**算法来进行回收, 不必进行内存复制, 且直接腾出空闲内存。即：

- 新生代：存活率低，使用复制算法
- 老年代：存活率高，使用“标记-整理”或“标记-清除”算法

##### **垃圾收集器**

###### 重点笔记：

- 并行（Parallel）：多条垃圾收集线程
- 并发（Concurrent）：用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户线程在继续运行，而垃圾收集程序运行于另外一个CPU上。
- 新生代：Serial收集器　　ParNew收集器　　Parallel Scavenge收集器
- 老年代：Serial Old收集器　　Parallel Old收集器　　CMS收集器



![img](https:////upload-images.jianshu.io/upload_images/13202633-02c7535022184c9f.png?imageMogr2/auto-orient/strip|imageView2/2/w/547/format/webp)



##### **新生代**

###### 1. Serial收集器

  最悠久，最基本的收集器；**单线程**收集器，只使用一个CPU或一条收集线程去完成垃圾收集工作，且在收集时，必须暂停其他所有的工作线程，直到收集结束。**新生代采取复制算法**。**老年代采取标记整理算法**。在进行垃圾收集时必须暂停其他所有的工作线程，即“Stop The World”。依然是虚拟机运行在Client模式下的默认新生代收集器。简单而高效（与其他收集器单线程相比），对于单个CPU环境来说，Serial收集器由于没有线程交互的开销，专注于垃圾回收，因此能获得最高的单线程收集效率。



![img](https:////upload-images.jianshu.io/upload_images/13202633-85a2f1863d76afe6.png?imageMogr2/auto-orient/strip|imageView2/2/w/409/format/webp)



###### 2.ParNew收集器

  Serial收集器的多线程版。**多条线程**进行垃圾收集，采用**复制算法**。其余和Serial收集器一样。目前唯一能与CMS收集器配合工作。



![img](https:////upload-images.jianshu.io/upload_images/13202633-41709c95aa0c129f.png?imageMogr2/auto-orient/strip|imageView2/2/w/473/format/webp)

###### 3. Parallel Scavenge收集器

  新生代收集器，**多线程并行**、使用**复制算法**。

  CMS的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而PS收集器的目的则是达到一个可控制的吞吐量。吞吐量即CPU用于运行用户代码的时间与CPU总消耗时间的比值（吞吐量=运行用户代码的时间/（运行用户代码的时间+垃圾收集的时间））。



![img](https:////upload-images.jianshu.io/upload_images/13202633-a9b25611e8a0c35e.png?imageMogr2/auto-orient/strip|imageView2/2/w/484/format/webp)



##### **老年代**

###### 4.Serial Old收集器

  Serial Old同样是**单线程**收集器,使用“**标记-整理**”算法。可以与JDK1.5及之前的Parallel Scavenge搭配使用；也可以作为CMS收集器的后备预案，在并发收集发生Concureent Mode Failure时使用。

###### 5.Parallel Old收集器

  Parallel Old收集器是**多线程**，使用“**标记-整理**”算法。

  JDK1.6前，Parallel Scavenge只能与老年代收集器Serial Old（PS MarkSweep）组合，由于Serial Old无法充分利用服务器多CPU的处理能力，会拖累整体性能。

  JDK1.6后，Parallel Scavenge可与Parallel Old组合，达到名副其实的“吞吐量优先”，在注重吞吐量以及CPU资源敏感的场合可以优先考虑这个组合。

###### 6.CMS收集器

  基于“**标记—清除**”算法，低停顿，**并发收集**。以获取最短回收停顿时间、低延迟为目标，适用于重视服务响应速度的应用。

主要过程为一下四步：

- 初始标记；Stop the World，仅标记GCRoots能关联的对象，速度很快。
- 并发标记；进行GCRootsTracing的过程。
- 重新标记；修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。比1长但远比2短。
- 并发清除；并发清除与并发标记耗时最长。收集器线程都可以与用户线程一起工作。并发清理以后重置线程。

**CMS收集器的内存回收过程是与用户线程一起并发执行的**

**主要缺点：**

- CMS对CPU资源非常敏感。
- CMS无法处理浮动垃圾（Floating Garbage），可能出现Concurrent Mode Failure失败而导致另一次Full GC的产生。
- CMS是标记清除，会产生大量碎片空间，对大对象内存分配带来麻烦。



![img](https:////upload-images.jianshu.io/upload_images/13202633-f92bcee0ed05d04a.png?imageMogr2/auto-orient/strip|imageView2/2/w/472/format/webp)



###### 7.G1收集器

  与其他基于分代的收集器不同，G1将整个Java堆划分为多个大小相等的独立区域Region，新生代和老年代不再是物理隔离的。

- 从整体来看：“标记-整理” 算法
- 从局部（两个Region之间）来看：“复制”算法

#### **五.内存分配与回收策略**

##### 重点笔记：

- 新生代GC（Minor GC）：发生在新生代的垃圾收集动作，非常频繁，一般回收速度也比较快。
- 老年代GC（Major GC/Full GC）：发生在老年代的垃圾收集动作，一般会伴随Minor GC 速度一般比Minor GC慢上10倍以上。

###### 1. 优先在Eden区分配

​	（如果启动本地线程分配缓冲TLAB-Thread Local Allocation Buffer，则优先在TLAB）如果Eden区满，则触发一次**Minor GC**

###### 2. 大对象直接进入老年代；

​	大对象，即大量连续内存空间的Java对象，最典型的是那种很长的字符串及数组。

###### 3. 长期存活的对象将进入老年代；

设置对象年龄计数器。对象在Eden出生并经过第一次MinorGC后仍存活，年龄+1，移入Survivor区。以后每经过一次MinorGC年龄加一，当达到15时（默认的）就进入老年代

###### 4. 动态对象年龄判定，

并不是对象年龄必须达到最大阈值才会进入老年代。如果survivor空间中相同年龄所有对象大小总和大于其空间的一般，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到阈值时才进入。

###### 5. 空间分配担保；

发生minorGC之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，成立，MinorGC可以确保是安全的。不成立，则检查HandlePromotionFailure设置值是否允许担保失败。允许，则检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小。**大于将尝试MinorGC，小于或者不允许冒险，也要进行一次FullGC**。老年代分配担保，将survivor无法容纳的对象直接进入老年代。依然担保失败，则只好在失败后重新发起一次Full GC。



#### 六，其他

##### 一，引用

​	在判断对象是否存活的时候无论使用那种算法，判断对象的存活与否都与“引用”有关。

​	JDK1.2之前，Java中的引用的定义很传统：如果reference类型的数据中存储的数值代表的是另一块内存的起始地址，就成这块内存代表着一个引用。

因为上述的定义太过狭隘，不符合期望，一般所描述的对象：当内存空间还足够的时候，则能保留在内存中；如果内存空间在进行垃圾手机后还是十分紧张的，则可以抛弃这些对象。



​	JDK1.2之后，Java对引用的定义进行了扩充，将引用分为强引用，软引用，弱引用，虚引用4种，而引用强度一次递减。



- **强引用**：指的是在应用程序中普遍常见的，比如说new 出来的对象，这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象
- **软引用**：用来描述一些有用但是并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出的异常之前，将会将这些对象列进回收范围之中进行第二次回收。如果此次回收还是没有足够的内存，才会抛出内存溢出异常。在JDK1.2之后，提供了SoftReference类来实现软引用
- **弱引用**：用来描述一些非必需对象，但是强度比软引用更弱一些，被软引用关联的对象只能生存到下一次垃圾收集发生之前。在垃圾收集器工作的时候，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，提供了SoftReference类来实现弱引用。
- **虚引用**：又称为幽灵引用或者是幻影引用，是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获取一个对象实例。为一个对象设置虚引用关联的唯一目的就是能够在这个对象被收集器回收时收到一个系统通知。在JDN1.2之后，提供了一个PhantomReference类来实现这个引用。



**而不同的引用类型**，**主要体现的是对象不同的可达性状态和对垃圾收集的影响**



##### 二，生存还是死亡，论一个对象自救的过程



​	即使在可达性算法中不可达的对象，也并非是“非死不可”的，这时候他们暂时处于缓刑阶段，要真正宣告一个对象死亡，至少要经历两个标记过程：如果对象在进行可达性分析之后发现场没有与GC Roots相连接的引用链，那它将会被第一次标记并进行一次筛选，条件是这个对象有没有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法一晶被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。

​	如果被判定有必要执行finalize()方法，则这个对象就会被放置在一个叫做F-Queue的队列之中，并在稍后有一个由虚拟机自动建立的，低优先级的Finalizer线程去执行他。这里的执行指的是会去触发这个方法，但并不承诺会等待它运行结束，而这样做的原因是：如果一个对象在finalize()方法中执行缓慢，或者是发生了死循环，将很有可能导致这个队列中的其他对下颌骨永久处于等待，甚至会导致整个内存回收系统崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只需要与引用链上的任意一个对象建立关联即可，譬如将自己的关键字赋值给某个类的变量或对象的成员变量，在第二次标记时它将被移除出“即将回收”集合；如果对象这时候没有逃脱，基本上就真的被回收了。

注：

​	1，任何对象的finalize方法只会被系统自动调用一次，如果该对象面临下一次回收，他的finalize()方法不会被再次执行，因此第一次自救行动就会失败。

##### 三，回收方法区：

1，方法区(或HotSpot虚拟机中的永久代)：在Java虚拟机的规范中说过可以不要求虚拟机在方法区中实现垃圾收集，而且在方法区中进行垃圾分类的性价比比较低：堆，尤其是新生代中，一次垃圾收集一般可以回收75-90的空间，而方法区远低于此。

2，永久代的垃圾收集主要收集两个部分：**废弃常量**和**=无用的类**。

​	以常量池中的字面量的回收为例：如果在发生内存回收的时候，没有任何对象引用这个常量，也没有其他地方引用这个常量的时候，必要的话，这个常量就会被系统清理出常量池。而常量池中的其他的类(接口)，方法，字段的符号引用也于此类似

3，判断一个常量是否是废弃常量的十分简单，但是判断一个类是否是“无用的类”则十分苛刻,需要同时满足以下三个条件：

​	①：该类所有的实例都已经被回收，也就是说Java堆中不存在再累的任何实例

​	②：加载该类的ClassLoader已经被回收了

​	③：该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

**满足以上三个条件仅仅是可以回收无用的类，并非和无用的对象一样**

在大量使用反射，动态代理，CGLib等ByteCode框架，动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要具备类卸载的功能，以保证永久代不会溢出

 

#### 七，内存分配和回收策略：

Java技术体系中所提倡的地洞内存管理最终可以归结为自动化的解决两个问题**给对象分配内存**和**回收分配给对象的内存**。

​	对象的内存分配为两种：就是在堆上分配(但也可能经过JIT编译后被拆散为标量类型并间接的栈上分配)，对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分百固定的，七夕节取决于当前使用的哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。

​	

##### 1，内存分配规则：

###### 	1，对象有限在Eden分配

​		大多数情况下，对象在新生代Eden区分配。**当Eden区没有足够的空间分配是，虚拟机将会发起一次Minor　GC。**

###### 2,大对象直接进入老年代

​	所谓的大对象指的是,需要大量来纳许内存空间的对象,最经典的就是那种很长的字符串以及数组.大对象堆虚拟机的内存分配来说即使一个坏消息,经常出现大对象容易导致内存还有不少的空间是就提前触发垃圾收集以获得足够的来纳许空间来"安置"他们.

###### 3,长期存活的对象直接进入老年代

​	为了方便在擦用分代收集算法来管理内存时,能够识别哪些对象用改放到新生代,那些应该放入老年代,虚拟机为每个对象定义了一个对象年龄计数器.**如果对象在Eden出生并经过第一次Minor GC后仍然存活,并且能够被Survivor容纳的话,将会被移动到Survivor空间中,并且将对象的年龄设置为1,当年龄增加到一定程度(莫尔奈威15),就将其晋升到老年代中**.而对象谨慎的高老年代的年龄阈值,可以通过参数-XX:MaxTenuringThreshold来设置.

###### 4，动态对象年龄判定

​	为了更好的使用不同程序的内存状况，虚拟机并不是永远的要求对象的年龄必须达到了MaxTenuringThreshold才能晋升为老年代，**如果在Survivor空间中相同年龄所有对象的大小的总和大于Survivor空间的一半，年龄大于或等于改年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中达到的年龄。**

###### 5，空间分配担保

​	在发生Minor GC之前，虚拟机会检查老年代最大可用的来纳许空间是否大于所有对象总空间，如果这个条件，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，会继续检查老年代在最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC,尽管这次Minor GC是由风险的；如果小于，或者是HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。







在整个过程中，经常对 Minor、Major、和 Full GC 事件的使用感到困惑。这也是我写这篇博客的原因，我希望能清楚地解释这其中的一些疑惑。

**文章要求读者熟悉 JVM 内置的通用垃圾回收原则。**堆内存划分为 Eden、Survivor 和 Tenured/Old 空间，代假设和其他不同的 GC 算法超出了本文讨论的范围。

![img](%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5.assets/v2-3b4c3f17dc268fb9eaaa38d0532e30a6_720w.jpg)

## **Minor GC**

从年轻代空间（包括 Eden 和 Survivor 区域）回收内存被称为 Minor GC。这一定义既清晰又易于理解。但是，当发生Minor GC事件的时候，有一些有趣的地方需要注意到：

1、当 JVM 无法为一个新的对象分配空间时会触发 Minor GC，比如当 Eden 区满了。所以分配率越高，越频繁执行 Minor GC。

2、内存池被填满的时候，其中的内容全部会被复制，指针会从0开始跟踪空闲内存。Eden 和 Survivor 区进行了标记和复制操作，取代了经典的标记、扫描、压缩、清理操作。所以 Eden 和 Survivor 区不存在内存碎片。写指针总是停留在所使用内存池的顶部。

3、执行 Minor GC 操作时，不会影响到永久代。从永久代到年轻代的引用被当成 GC roots，从年轻代到永久代的引用在标记阶段被直接忽略掉。

4、**质疑常规的认知，所有的 Minor GC 都会触发“全世界的暂停（stop-the-world）”，停止应用程序的线程。**对于大部分应用程序，停顿导致的延迟都是可以忽略不计的。其中的真相就 是，大部分 Eden 区中的对象都能被认为是垃圾，永远也不会被复制到 Survivor 区或者老年代空间。如果正好相反，Eden 区大部分新生对象不符合 GC 条件，Minor GC 执行时暂停的时间将会长很多。

所以 Minor GC 的情况就相当清楚了——**每次 Minor GC 会清理年轻代的内存。**

## **Major GC vs Full GC**

大家应该注意到，目前，这些术语无论是在 JVM 规范还是在垃圾收集研究论文中都没有正式的定义。但是我们一看就知道这些在我们已经知道的基础之上做出的定义是正确的，Minor GC 清理年轻带内存应该被设计得简单：

- **Major GC 是清理老年代。**
- **Full GC 是清理整个堆空间—包括年轻代和老年代。**

很不幸，实际上它还有点复杂且令人困惑。首先，许多 Major GC 是由 Minor GC 触发的，所以很多情况下将这两种 GC 分离是不太可能的。另一方面，许多现代垃圾收集机制会清理部分永久代空间，所以使用“cleaning”一词只是部分正确。

这使得我们不用去关心到底是叫 **Major GC 还是 Full GC，大家应该关注当前的 GC 是否停止了所有应用程序的线程，还是能够并发的处理而不用停掉应用程序的线程。**

这种混乱甚至内置到 JVM 标准工具。下面一个例子很好的解释了我的意思。让我们比较两个不同的工具 Concurrent Mark 和 Sweep collector (-XX:+UseConcMarkSweepGC)在 JVM 中运行时输出的跟踪记录。

第一次尝试通过 jstat 输出：

```java
my-precious: me$ jstat -gc -t 4235 1sTime S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT    5.7 34048.0 34048.0  0.0   34048.0 272640.0 194699.7 1756416.0   181419.9  18304.0 17865.1 2688.0 2497.6      3    0.275   0      0.000    0.275 6.7 34048.0 34048.0 34048.0  0.0   272640.0 247555.4 1756416.0   263447.9  18816.0 18123.3 2688.0 2523.1      4    0.359   0      0.000    0.359 7.7 34048.0 34048.0  0.0   34048.0 272640.0 257729.3 1756416.0   345109.8  19072.0 18396.6 2688.0 2550.3      5    0.451   0      0.000    0.451 8.7 34048.0 34048.0 34048.0 34048.0 272640.0 272640.0 1756416.0  444982.5  19456.0 18681.3 2816.0 2575.8      7    0.550   0      0.000    0.550 9.7 34048.0 34048.0 34046.7  0.0   272640.0 16777.0  1756416.0   587906.3  20096.0 19235.1 2944.0 2631.8      8    0.720   0      0.000    0.72010.7 34048.0 34048.0  0.0   34046.2 272640.0 80171.6  1756416.0   664913.4  20352.0 19495.9 2944.0 2657.4      9    0.810   0      0.000    0.81011.7 34048.0 34048.0 34048.0  0.0   272640.0 129480.8 1756416.0   745100.2  20608.0 19704.5 2944.0 2678.4     10    0.896   0      0.000    0.89612.7 34048.0 34048.0  0.0   34046.6 272640.0 164070.7 1756416.0   822073.7  20992.0 19937.1 3072.0 2702.8     11    0.978   0      0.000    0.97813.7 34048.0 34048.0 34048.0  0.0   272640.0 211949.9 1756416.0   897364.4  21248.0 20179.6 3072.0 2728.1     12    1.087   1      0.004    1.09114.7 34048.0 34048.0  0.0   34047.1 272640.0 245801.5 1756416.0   597362.6  21504.0 20390.6 3072.0 2750.3     13    1.183   2      0.050    1.23315.7 34048.0 34048.0  0.0   34048.0 272640.0 21474.1  1756416.0   757347.0  22012.0 20792.0 3200.0 2791.0     15    1.336   2      0.050    1.38616.7 34048.0 34048.0 34047.0  0.0   272640.0 48378.0  1756416.0   838594.4  22268.0 21003.5 3200.0 2813.2     16    1.433   2      0.050    1.484
```

这个片段是 JVM 启动后第17秒提取的。基于该信息，我们可以得出这样的结果，运行了12次 Minor GC、2次 Full GC，时间总跨度为50毫秒。通过 jconsole 或者 jvisualvm 这样的基于GUI的工具你能得到同样的结果。

```java
java -XX:+PrintGCDetails -XX:+UseConcMarkSweepGC eu.plumbr.demo.GarbageProducer3.157: [GC (Allocation Failure) 3.157: [ParNew: 272640K->34048K(306688K), 0.0844702 secs] 272640K->69574K(2063104K), 0.0845560 secs] [Times: user=0.23 sys=0.03, real=0.09 secs] 4.092: [GC (Allocation Failure) 4.092: [ParNew: 306688K->34048K(306688K), 0.1013723 secs] 342214K->136584K(2063104K), 0.1014307 secs] [Times: user=0.25 sys=0.05, real=0.10 secs] ... cut for brevity ...11.292: [GC (Allocation Failure) 11.292: [ParNew: 306686K->34048K(306688K), 0.0857219 secs] 971599K->779148K(2063104K), 0.0857875 secs] [Times: user=0.26 sys=0.04, real=0.09 secs] 12.140: [GC (Allocation Failure) 12.140: [ParNew: 306688K->34046K(306688K), 0.0821774 secs] 1051788K->856120K(2063104K), 0.0822400 secs] [Times: user=0.25 sys=0.03, real=0.08 secs] 12.989: [GC (Allocation Failure) 12.989: [ParNew: 306686K->34048K(306688K), 0.1086667 secs] 1128760K->931412K(2063104K), 0.1087416 secs] [Times: user=0.24 sys=0.04, real=0.11 secs] 13.098: [GC (CMS Initial Mark) [1 CMS-initial-mark: 897364K(1756416K)] 936667K(2063104K), 0.0041705 secs] [Times: user=0.02 sys=0.00, real=0.00 secs] 13.102: [CMS-concurrent-mark-start]13.341: [CMS-concurrent-mark: 0.238/0.238 secs] [Times: user=0.36 sys=0.01, real=0.24 secs] 13.341: [CMS-concurrent-preclean-start]13.350: [CMS-concurrent-preclean: 0.009/0.009 secs] [Times: user=0.03 sys=0.00, real=0.01 secs] 13.350: [CMS-concurrent-abortable-preclean-start]13.878: [GC (Allocation Failure) 13.878: [ParNew: 306688K->34047K(306688K), 0.0960456 secs] 1204052K->1010638K(2063104K), 0.0961542 secs] [Times: user=0.29 sys=0.04, real=0.09 secs] 14.366: [CMS-concurrent-abortable-preclean: 0.917/1.016 secs] [Times: user=2.22 sys=0.07, real=1.01 secs] 14.366: [GC (CMS Final Remark) [YG occupancy: 182593 K (306688 K)]14.366: [Rescan (parallel) , 0.0291598 secs]14.395: [weak refs processing, 0.0000232 secs]14.395: [class unloading, 0.0117661 secs]14.407: [scrub symbol table, 0.0015323 secs]14.409: [scrub string table, 0.0003221 secs][1 CMS-remark: 976591K(1756416K)] 1159184K(2063104K), 0.0462010 secs] [Times: user=0.14 sys=0.00, real=0.05 secs] 14.412: [CMS-concurrent-sweep-start]14.633: [CMS-concurrent-sweep: 0.221/0.221 secs] [Times: user=0.37 sys=0.00, real=0.22 secs] 14.633: [CMS-concurrent-reset-start]14.636: [CMS-concurrent-reset: 0.002/0.002 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
```

在点头同意这个结论之前，让我们看看来自同一个 JVM 启动收集的垃圾收集日志的输出。显然- XX ： + PrintGCDetails 告诉我们一个不同且更详细的故事：

基于这些信息，我们可以看到12次 Minor GC 后开始有些和上面不一样了。没有运行两次 Full GC，这不同的地方在于单个 GC 在永久代中不同阶段运行了两次：

1、最初的标记阶段，用了0.0041705秒也就是4ms左右。这个阶段会暂停“全世界（ stop-the-world）”的事件，停止所有应用程序的线程，然后开始标记。

2、并行执行标记和清洗阶段。这些都是和应用程序线程并行的。

3、最后 Remark 阶段，花费了0.0462010秒约46ms。这个阶段会再次暂停所有的事件。

4、并行执行清理操作。正如其名，此阶段也是并行的，不会停止其他线程。

所以，正如我们从垃圾回收日志中所看到的那样，实际上只是执行了 Major GC 去清理老年代空间而已，而不是执行了两次 Full GC。

如果你是后期做决 定的话，那么由 jstat 提供的数据会引导你做出正确的决策。它正确列出的两个暂停所有事件的情况，导致所有线程停止了共计50ms。但是如果你试图优化吞吐量，你会被误导的。清 单只列出了回收初始标记和最终 Remark 阶段，jstat的输出看不到那些并发完成的工作。

## **结论**

考虑到这种情况，最好避免以 Minor、Major、Full GC 这种方式来思考问题。而应该监控应用延迟或者吞吐量，然后将 GC 事件和结果联系起来。

随着这些 GC 事件的发生，你需要额外的关注某些信息，GC 事件是强制所有应用程序线程停止了还是并行的处理了部分事件。